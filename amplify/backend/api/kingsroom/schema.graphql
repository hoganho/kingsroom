# =======================================
# CORE ENUMS
# =======================================
enum DataSource { SCRAPE, API, MANUAL }
enum AssetCondition { NEW, GOOD, FAIR, POOR, RETIRED }
enum VenueStatus { ACTIVE, INACTIVE, PENDING }
enum GameType { TOURNAMENT, CASH_GAME }
enum GameStatus { SCHEDULED, RUNNING, COMPLETED, CANCELLED, FINISHED }
enum GameVariant { NLHE, PLO, PLO5, PLO6 }
enum GameFrequency { DAILY, WEEKLY, FORTNIGHTLY, MONTHLY, QUARTERLY, YEARLY, UNKNOWN }
enum RegistrationStatus { OPEN, CLOSED }
enum TournamentType { FREEZEOUT, REBUY, SATELLITE, DEEPSTACK }
enum PaymentSourceType { CASH, SQUARE, CREDIT, UNKNOWN }
enum PlayerAccountStatus { ACTIVE, SUSPENDED, PENDING_VERIFICATION }
enum PlayerAccountCategory { NEW, RECREATIONAL, REGULAR, VIP, LAPSED }
enum SeriesStatus { LIVE, SCHEDULED, COMPLETED }

# UPDATED: Populated the enum with targeting values
enum PlayerTargetingClassification {
  NotPlayed
  Active_EL
  Active
  Retain_Inactive31_60d
  Retain_Inactive61_90d
  Churned_91_120d
  Churned_121_180d
  Churned_181_360d
  Churned_361d
}

# NEW: Added a new enum for venue-specific targeting
enum PlayerVenueTargetingClassification {
  Active_EL
  Active
  Retain_Inactive31_60d
  Retain_Inactive61_90d
  Churned_91_120d
  Churned_121_180d
  Churned_181_360d
  Churned_361d
}

enum TransactionType { BUY_IN, DEPOSIT, TICKET_AWARD, TICKET_REDEMPTION, CASH_AWARD, QUALIFICATION, WITHDRAWAL }
enum MessageStatus { SENT, DELIVERED, FAILED, READ }
enum UserRole { SUPER_ADMIN, ADMIN, VENUE_MANAGER, TOURNAMENT_DIRECTOR, MARKETING }
enum StaffRole { DEALER, FLOOR_MANAGER, SERVICE, TOURNAMENT_DIRECTOR }
enum TicketStatus { ACTIVE, EXPIRED, USED }

# =======================================
# SCRAPE/DATA SYNC MANAGEMENT
# =======================================
type DataSync @model @auth(rules: [{ allow: private }]) {
  id: ID!
  syncedAt: AWSDateTime!
  method: DataSource!
  sourceUrl: AWSURL
  title: String
  content: String
}

# =======================================
# SCRAPER STRUCTURE MANAGEMENT
# =======================================

type ScrapeStructure @model @auth(rules: [{ allow: private }]) {
  id: ID! # This will be the SHA-256 hash of the fields
  fields: [String]! # The sorted list of data keys found on the page
  structureLabel: String # ✅ NEW: Combo of status and registrationStatus
  occurrenceCount: Int! # How many times we've seen this structure
  firstSeenAt: AWSDateTime!
  lastSeenAt: AWSDateTime!
  exampleUrl: AWSURL # A sample URL where this structure was found
}

# =======================================
# INVENTORY MANAGEMENT
# =======================================
type Asset @model @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  type: String! # e.g., "Playing Cards", "Poker Table", "Chip Set"
  condition: AssetCondition!
  acquiredDate: AWSDate!
  lastCheckedDate: AWSDate!
  venueId: ID! @index(name: "byVenue")
  venue: Venue @belongsTo(fields: ["venueId"])
}

# =======================================
# VENUE MANAGEMENT
# =======================================
type Venue @model @auth(rules: [{ allow: private }]) {
  id: ID!
  venueNumber: Int! @index(name: "byVenueNumber", sortKeyFields: ["name"])
  name: String!
  aliases: [String]
  address: String
  city: String
  country: String
  details: VenueDetails @hasOne
  assets: [Asset] @hasMany(indexName: "byVenue", fields: ["id"])
  games: [Game] @hasMany(indexName: "byVenue", fields: ["id"])
  series: [TournamentSeries] @hasMany(indexName: "byVenue", fields: ["id"])
  playerMemberships: [PlayerVenue] @hasMany(indexName: "byVenue", fields: ["id"])
}

type VenueDetails @model @auth(rules: [{ allow: private }]) {
  id: ID!
  venueId: ID! @index(name: "byVenue")
  startDate: AWSDate!
  status: VenueStatus!
  lastCustomerSuccessVisit: AWSDate
  totalGamesHeld: Int
  averagePlayersPerGame: Float
  gameNights: [String] # e.g., ["Monday", "Friday"]
  venue: Venue @belongsTo(fields: ["venueId"])
}

# =======================================
# NEW: TOURNAMENT SERIES MANAGEMENT
# =======================================

type TournamentSeriesTitle @model @auth(rules: [{ allow: private }]) {
  id: ID!
  title: String!
  # One-to-Many: One Title can have many Series instances over the years
  seriesInstances: [TournamentSeries] @hasMany(indexName: "byTournamentSeriesTitle", fields: ["id"])
}

type TournamentSeries @model @auth(rules: [{ allow: private }]) {
  id: ID!
  year: Int!
  name: String! # e.g., "Sydney Millions 2025"
  aliases: [String]
  startDate: AWSDate
  endDate: AWSDate
  events: [String] # A simple array of event names or descriptions
  numberOfEvents: Int
  guaranteedPrizepool: Float
  estimatedPrizepool: Float
  actualPrizepool: Float
  status: SeriesStatus!

  # Many-to-One: Many series can belong to one title
  tournamentSeriesTitleId: ID! @index(name: "byTournamentSeriesTitle", sortKeyFields: ["year"])
  title: TournamentSeriesTitle @belongsTo(fields: ["tournamentSeriesTitleId"])

  # Many-to-One: Many series can be held at one venue
  venueId: ID! @index(name: "byVenue")
  venue: Venue @belongsTo(fields: ["venueId"])

  # One-to-Many: One series can contain many games
  games: [Game] @hasMany(indexName: "byTournamentSeries", fields: ["id"])
}

# =======================================
# CUSTOM TYPES FOR OUR NEW OPERATIONS
# =======================================

type ScrapedGameSummary {
    id: String!
    name: String
    status: String
    registrationStatus: String
    gameStartDateTime: String
    inDatabase: Boolean
    doNotScrape: Boolean
    error: String
}

# This type defines the shape of the data our scraper will return.
# It is NOT a database model.
type ScrapedGameData {
    name: String!
    gameStartDateTime: String
    gameEndDateTime: String
    gameStatus: GameStatus
    registrationStatus: String
    gameType: GameType
    gameVariant: GameVariant
    tournamentType: TournamentType
    prizepool: Float
    revenueByBuyIns: Float
    profitLoss: Float
    totalEntries: Int
    totalRebuys: Int
    totalAddons: Int
    
    # Running game info
    playersRemaining: Int
    totalChipsInPlay: Float
    averagePlayerStack: Float
    
    totalDuration: String
    gameTags: [String]
    buyIn: Float
    rake: Float
    totalRake: Float
    startingStack: Int
    hasGuarantee: Boolean
    guaranteeAmount: Float
    guaranteeOverlay: Float
    guaranteeSurplus: Float
    
    seriesName: String
    isRegular: Boolean
    isSeries: Boolean
    isRecurring: Boolean
    gameFrequency: GameFrequency

    isSatellite: Boolean
    levels: [ScrapedTournamentLevel!]
    breaks: [ScrapedBreak!]
    entries: [ScrapedPlayerEntries!]
    seating: [ScrapedPlayerSeating!]
    results: [ScrapedPlayerResult!]
    tables: [ScrapedTables!]
    rawHtml: String
    isNewStructure: Boolean
    structureLabel: String
    foundKeys: [String]
    venueMatch: ScrapedVenueMatch
}

type ScrapedTournamentLevel {
    levelNumber: Int!
    durationMinutes: Int
    smallBlind: Int
    bigBlind: Int
    ante: Int
}

type ScrapedBreak {
    levelNumberBeforeBreak: Int!
    levelNumberAfterBreak: Int!
    durationMinutes: Int
}

type ScrapedPlayerEntries {
    name: String!
}

type ScrapedPlayerSeating {
    name: String!
    table: Int
    seat: Int
    playerStack: Int
}

type ScrapedPlayerResult {
    rank: Int!
    name: String!
    winnings: Float
    points: Float
}

type ScrapedTables {
    tableName: String!
    seats: [ScrapedTableSeatsData!]
}

type ScrapedVenueMatch {
    autoAssignedVenue: ScrapedVenueMatchDetails
    suggestions: [ScrapedVenueMatchDetails!]
}

type ScrapedVenueMatchDetails {
    id: ID!
    name: String!
    score: Float!
}

type ScrapedTableSeatsData {
    seat: Int!
    isOccupied: Boolean!
    playerName: String
    playerStack: Int
}

# This is the input type for our save operation.
input SaveTournamentInput {
    existingGameId: ID
    doNotScrape: Boolean
    sourceUrl: AWSURL!
    venueId: ID!
    data: ScrapedGameDataInput!
}

input ScrapedGameDataInput {
    name: String!
    gameStartDateTime: String
    gameEndDateTime: String
    gameStatus: GameStatus
    registrationStatus: RegistrationStatus
    gameType: GameType
    gameVariant: GameVariant
    prizepool: Float
    totalEntries: Int
    totalRebuys: Int
    totalAddons: Int
    totalDuration: String
    gameTags: [String]
    tournamentType: TournamentType
    buyIn: Float
    rake: Float
    startingStack: Int
    hasGuarantee: Boolean
    guaranteeAmount: Float
    levels: [ScrapedTournamentLevelInput!]
    breaks: [ScrapedBreakInput!]
    # ✅ CORRECTED: Use the new input types below
    entries: [ScrapedPlayerEntriesInput!]
    seating: [ScrapedPlayerSeatingInput!]
    results: [ScrapedPlayerResultInput!]
}

# ✅ NEW: Corresponding input types for nested data structures
input ScrapedPlayerEntriesInput {
    name: String!
}

input ScrapedPlayerSeatingInput {
    name: String!
    table: Int
    seat: Int
    playerStack: Int
}

input ScrapedPlayerResultInput {
    rank: Int!
    name: String!
    winnings: Float
    points: Float
}
# (End of new input types)

input ScrapedTournamentLevelInput {
    levelNumber: Int!
    durationMinutes: Int
    smallBlind: Int
    bigBlind: Int
    ante: Int
}

input ScrapedBreakInput {
    levelNumberBeforeBreak: Int!
    levelNumberAfterBreak: Int
    durationMinutes: Int
}

# =======================================
# GAME MANAGEMENT
# =======================================
type Game @model @auth(rules: [{ allow: private }]) {
    id: ID!
    name: String!
    gameType: GameType!
    gameVariant: GameVariant!
    gameStatus: GameStatus!
    gameStartDateTime: AWSDateTime!
    gameEndDateTime: AWSDateTime
    venueId: ID! @index(name: "byVenue", sortKeyFields: ["gameStartDateTime"])
    sourceUrl: AWSURL @index(name: "bySourceUrl", queryField: "gameBySourceUrl")
    doNotScrape: Boolean!
    sourceDataIssue: Boolean!
    gameDataVerified: Boolean!

    # Basic game info
    seriesName: String
    isRegular: Boolean
    isSeries: Boolean
    isRecurring: Boolean
    gameFrequency: GameFrequency
    isSatellite: Boolean
    registrationStatus: String
    prizepool: Float
    revenueByBuyIns: Float
    totalEntries: Int
    totalRebuys: Int
    totalAddons: Int
    totalDuration: String
    gameTags: [String]
    
    # Tournament-specific fields (moved from TournamentStructure)
    tournamentType: TournamentType # FREEZEOUT, REBUY, etc.
    buyIn: Float
    rake: Float
    totalRake: Float
    profitLoss: Float
    startingStack: Int
    hasGuarantee: Boolean
    guaranteeAmount: Float
    guaranteeOverlay: Float
    guaranteeSurplus: Float

    # Running game info
    playersRemaining: Int
    totalChipsInPlay: Float
    averagePlayerStack: Float

    # Blind structure reference (optional - for reusable structures)
    tournamentStructureId: ID @index(name: "byTournamentStructure")
    
    # Cash game structure (unchanged)
    cashStructureId: ID @index(name: "byCashStructure")
    
    # Relationships
    venue: Venue @belongsTo(fields: ["venueId"])
    tournamentStructure: TournamentStructure @belongsTo(fields: ["tournamentStructureId"])
    cashStructure: CashStructure @belongsTo(fields: ["cashStructureId"])
    playerResults: [PlayerResult] @hasMany(indexName: "byGame", fields: ["id"])
    tournamentSeriesId: ID @index(name: "byTournamentSeries")
    tournamentSeries: TournamentSeries @belongsTo(fields: ["tournamentSeriesId"])
}

# Simplified TournamentStructure - now just for blind levels
type TournamentStructure @model @auth(rules: [{ allow: private }]) {
    id: ID!
    name: String! # e.g., "Standard Daily Structure", "Turbo Structure"
    description: String
    # Embedded levels array instead of separate model
    levels: [TournamentLevelData]
    # Track which games use this structure
    games: [Game] @hasMany(indexName: "byTournamentStructure", fields: ["id"])
}

# Not a @model - just a type for embedding
type TournamentLevelData {
    levelNumber: Int!
    durationMinutes: Int!
    smallBlind: Int!
    bigBlind: Int!
    ante: Int
    breakMinutes: Int
}

type RakeStructure @model @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  rakePercentage: Float!
  maxRake: Float!
  cashStructures: [CashStructure] @hasMany(indexName: "byRakeStructure", fields: ["id"])
}

type CashStructure @model @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String! # e.g., "$1/$2 NLHE"
  smallBlind: Float!
  bigBlind: Float!
  minBuyIn: Float!
  maxBuyIn: Float!
  rakeStructureId: ID! @index(name: "byRakeStructure")
  rakeStructure: RakeStructure @belongsTo(fields: ["rakeStructureId"])
  games: [Game] @hasMany(indexName: "byCashStructure", fields: ["id"])
}

# =======================================
# PLAYER MANAGEMENT (Updated)
# =======================================

type Player @model @auth(rules: [{ allow: private }]) {
  id: ID!
  firstName: String!
  givenName: String
  lastName: String
  email: String @index(name: "byEmail", queryField: "playerByEmail")
  phone: String
  registrationVenueId: ID! @index(name: "byVenue")
  creationDate: AWSDateTime!
  lastPlayedDate: AWSDate
  status: PlayerAccountStatus!
  category: PlayerAccountCategory!
  targetingClassification: PlayerTargetingClassification!
  tier: String # e.g., "Bronze", "Silver", "Gold"
  transactions: [PlayerTransaction] @hasMany(indexName: "byPlayer", fields: ["id"])
  results: [PlayerResult] @hasMany(indexName: "byPlayer", fields: ["id"])
  tickets: [PlayerTicket] @hasMany(indexName: "byPlayer", fields: ["id"])
  marketingPreferences: PlayerMarketingPreferences @hasOne
  venueMemberships: [PlayerVenue] @hasMany(indexName: "byPlayer", fields: ["id"])
  # NEW: one-to-one relationship with PlayerSummary
  summary: PlayerSummary @hasOne
}

# NEW: Model to store derived player statistics for fast querying.
type PlayerSummary @model @auth(rules: [{ allow: private }]) {
  id: ID!
  playerId: ID! @index(name: "byPlayer")
  venuesVisited: [ID]
  sessionsPlayed: Int
  tournamentsPlayed: Int
  cashGamesPlayed: Int
  tournamentWinnings: Float
  tournamentBuyIns: Float
  cashGameWinnings: Float
  cashGameBuyIns: Float
  totalWinnings: Float
  totalBuyIns: Float
  netBalance: Float
  tournamentITM: Int
  tournamentsCashed: Int
  lastUpdated: AWSDateTime!
  player: Player @belongsTo(fields: ["playerId"])
}

type PlayerVenue @model @auth(rules: [{ allow: private }]) {
  id: ID!
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["venueId"])
  venueId: ID! @index(name: "byVenue", sortKeyFields: ["playerId"])
  totalGamesPlayed: Int
  averageBuyIn: Float
  firstPlayedDate: AWSDate
  lastPlayedDate: AWSDate
  targetingClassification: PlayerVenueTargetingClassification!
  player: Player @belongsTo(fields: ["playerId"])
  venue: Venue @belongsTo(fields: ["venueId"])
}

type PlayerTransaction @model @auth(rules: [{ allow: private }]) {
  id: ID!
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["transactionDate"])
  type: TransactionType!
  amount: Float!
  paymentSource: PaymentSourceType!
  transactionDate: AWSDateTime!
  rake: Float
  notes: String
  gameId: ID @index(name: "byGame") # Link to game for buy-ins
  player: Player @belongsTo(fields: ["playerId"])
}

type PlayerResult @model @auth(rules: [{ allow: private }]) {
  id: ID!
  playerId: ID! @index(name: "byPlayer")
  gameId: ID! @index(name: "byGame")
  finishingPlace: Int
  isMultiDayQualification: Boolean
  prizeWon: Boolean
  amountWon: Float
  totalRunners: Int
  game: Game @belongsTo(fields: ["gameId"])
  player: Player @belongsTo(fields: ["playerId"])
}

type PlayerMarketingMessage @model @auth(rules: [{ allow: private }]) {
  id: ID!
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["sentAt"])
  marketingMessageId: ID! @index(name: "byMarketingMessage")
  status: MessageStatus!
  sentAt: AWSDateTime!
}

type PlayerMarketingPreferences @model @auth(rules: [{ allow: private }]) {
  id: ID!
  playerId: ID! @index(name: "byPlayer")
  optOutSms: Boolean
  optOutEmail: Boolean
  player: Player @belongsTo(fields: ["playerId"])
}

type TicketTemplate @model @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  description: String
  value: Float!
  validityDays: Int! # How many days the ticket is valid for after being won
  originGameId: ID # The game where this ticket can be won
  targetGameId: ID # The game this ticket grants entry to
  playerTickets: [PlayerTicket] @hasMany(indexName: "byTicketTemplate", fields: ["id"])
}

type PlayerTicket @model @auth(rules: [{ allow: private }]) {
  id: ID!
  playerId: ID! @index(name: "byPlayer")
  ticketTemplateId: ID! @index(name: "byTicketTemplate")
  assignedAt: AWSDateTime!
  expiryDate: AWSDateTime!
  status: TicketStatus!
  usedInGameId: ID
  ticketTemplate: TicketTemplate @belongsTo(fields: ["ticketTemplateId"])
  player: Player @belongsTo(fields: ["playerId"])
}

type User @model @auth(rules: [
  { allow: owner, ownerField: "id", operations: [read, update] },
  { allow: private, operations: [read] },
  { allow: groups, groups: ["SUPER_ADMIN"], operations: [create, read, update, delete] }
]) {
  id: ID! # Uses Cognito username (sub)
  username: String!
  email: String!
  role: UserRole!
  preferences: [UserPreference] @hasMany(indexName: "byUser", fields: ["id"])
}

type Staff @model @auth(rules: [{ allow: private }]) {
  id: ID!
  firstName: String!
  lastName: String
  role: StaffRole!
  assignedVenueId: ID @index(name: "byVenue")
}

type UserPreference @model @auth(rules: [{ allow: owner, ownerField: "userId" }]) {
  id: ID!
  userId: ID! @index(name: "byUser")
  page: String! # e.g., "Dashboard"
  widget: String! # e.g., "Widget1"
  preference: AWSJSON # e.g., { "type": "TopVenues", "limit": 5 }
}

type SocialPost @model @auth(rules: [{ allow: private }]) {
  id: ID!
  socialAccountId: ID! @index(name: "bySocialAccount", sortKeyFields: ["postedAt"])
  content: String!
  imageUrl: AWSURL
  postedAt: AWSDateTime!
}

type SocialAccount @model @auth(rules: [{ allow: private }]) {
  id: ID!
  platform: String! # e.g., "Facebook", "Instagram"
  accountName: String!
  apiKey: String # Store securely
  apiSecret: String # Store securely
}

type MarketingMessage @model @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String! # Internal name for the campaign
  subject: String
  emailBody: String
  smsBody: String
  sentMessages: [PlayerMarketingMessage] @hasMany(indexName: "byMarketingMessage", fields: ["id"])
}

# =======================================
# CUSTOM MUTATIONS & QUERIES
# =======================================
type Query {
    fetchTournamentDataRange(startId: Int!, endId: Int!): [ScrapedGameSummary!] @function(name: "webScraperFunction-${env}")
}

type Mutation {
    fetchTournamentData(url: AWSURL!): ScrapedGameData @function(name: "webScraperFunction-${env}")
    saveTournamentData(input: SaveTournamentInput!): Game @function(name: "webScraperFunction-${env}")
}