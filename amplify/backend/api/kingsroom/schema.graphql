# ===================================================================
# KINGSROOM SCHEMA
# Version: 1.2.1 (Fixes: SyncPageInfoResult & GameTracker Types)
# ===================================================================

# ===================================================================
# 1. ENUMS
# ===================================================================

enum DataSource { SCRAPE, API, MANUAL }
enum AssetCondition { NEW, GOOD, FAIR, POOR, RETIRED }
enum VenueStatus { ACTIVE, INACTIVE, PENDING }
enum GameType { TOURNAMENT, CASH_GAME }
enum GameStatus { INITIATING, SCHEDULED, REGISTERING, RUNNING, CANCELLED, FINISHED, NOT_IN_USE, NOT_PUBLISHED, CLOCK_STOPPED, UNKNOWN }
enum GameVariant { NLHE, PLO, PLOM, PLO5, PLO6 }
enum GameFrequency { DAILY, WEEKLY, FORTNIGHTLY, MONTHLY, QUARTERLY, YEARLY, UNKNOWN }
enum RegistrationStatus { SCHEDULED, OPEN, FINAL, CLOSED, N_A }
enum TournamentType { FREEZEOUT, REBUY, SATELLITE, DEEPSTACK }
enum PaymentSourceType { CASH, SQUARE, CREDIT_CARD, INTERNAL_CREDIT, UNKNOWN }
enum PlayerAccountStatus { ACTIVE, SUSPENDED, PENDING_VERIFICATION }
enum PlayerAccountCategory { NEW, RECREATIONAL, REGULAR, VIP, LAPSED }
enum SeriesStatus { LIVE, SCHEDULED, COMPLETED }
enum PlayerTargetingClassification { NotPlayed, Active_EL, Active, Retain_Inactive31_60d, Retain_Inactive61_90d, Churned_91_120d, Churned_121_180d, Churned_181_360d, Churned_361d }
enum PlayerVenueTargetingClassification { Active_EL, Active, Retain_Inactive31_60d, Retain_Inactive61_90d, Churned_91_120d, Churned_121_180d, Churned_181_360d, Churned_361d }
enum TransactionType { BUY_IN, DEPOSIT, TICKET_AWARD, TICKET_REDEMPTION, CASH_AWARD, QUALIFICATION, WITHDRAWAL }
enum MessageStatus { SENT, DELIVERED, FAILED, READ }
enum UserRole { SUPER_ADMIN, ADMIN, VENUE_MANAGER, TOURNAMENT_DIRECTOR, MARKETING }
enum StaffRole { DEALER, FLOOR_MANAGER, SERVICE, TOURNAMENT_DIRECTOR }
enum TicketStatus { ACTIVE, EXPIRED, USED }
enum PlayerEntryStatus { REGISTERED, VOIDED, PLAYING, ELIMINATED, COMPLETED }
enum CreditTransactionType { AWARD_PROMOTION, AWARD_REFUND, AWARD_MANUAL, REDEEM_GAME_BUY_IN, EXPIRED }
enum PointsTransactionType { EARN_FROM_PLAY, EARN_FROM_PROMOTION, REDEEM_FOR_BUY_IN, REDEEM_FOR_MERCH, ADJUSTMENT_MANUAL, EXPIRED }
enum SeriesCategory { REGULAR, SPECIAL, PROMOTIONAL, CHAMPIONSHIP, SEASONAL }
enum HolidayType { NEW_YEAR, AUSTRALIA_DAY, EASTER, ANZAC_DAY, QUEENS_BIRTHDAY, CHRISTMAS, BOXING_DAY, OTHER }
enum VenueAssignmentStatus { AUTO_ASSIGNED, MANUALLY_ASSIGNED, PENDING_ASSIGNMENT, UNASSIGNED, RETROACTIVE_ASSIGNED }
enum SeriesAssignmentStatus { AUTO_ASSIGNED, MANUALLY_ASSIGNED, PENDING_ASSIGNMENT, UNASSIGNED, NOT_SERIES }
enum CostItemType { DEALER, TOURNAMENT_DIRECTOR, PRIZE_CONTRIBUTION, JACKPOT_CONTRIBUTION, PROMOTION, FLOOR_STAFF, SECURITY, EQUIPMENT_RENTAL, VENUE_RENTAL, INSURANCE, OTHER }
enum CostItemRateType { STANDARD, PENALTY, OVERTIME, HOLIDAY, SPECIAL }
enum EntryType { INITIAL, REENTRY, DIRECT_BUYIN, QUALIFIED_CONTINUATION, AGGREGATE_LISTING }
enum ScraperJobTriggerSource { SCHEDULED, MANUAL, API, CONTROL, BULK, ADMIN }
enum ScraperJobStatus { QUEUED, RUNNING, COMPLETED, FAILED, CANCELLED, TIMEOUT }
enum ScrapeURLStatus { ACTIVE, INACTIVE, DO_NOT_SCRAPE, ERROR, ARCHIVED }
enum ScrapeAttemptStatus { SUCCESS, FAILED, SKIPPED_DONOTSCRAPE, SKIPPED_VENUE, BLANK, NO_CHANGES, UPDATED, SAVED, SUCCESS_EDITED, SAVED_EDITED, UPDATED_EDITED }
enum TimeRange { LAST_HOUR, LAST_24_HOURS, LAST_7_DAYS, LAST_30_DAYS, CUSTOM }
enum ScraperOperation { START, STOP, ENABLE, DISABLE, STATUS, RESET }

# --- Social Pulse Enums ---
enum SocialPlatform { FACEBOOK, INSTAGRAM, TWITTER, LINKEDIN }
enum SocialAccountStatus { ACTIVE, INACTIVE, PENDING_VERIFICATION, ERROR, RATE_LIMITED }
enum SocialPostType { TEXT, IMAGE, VIDEO, LINK, EVENT, ALBUM, LIVE }
enum SocialScrapeStatus { SUCCESS, FAILED, SKIPPED, RATE_LIMITED, NO_NEW_CONTENT }
enum SocialPostStatus { ACTIVE, HIDDEN, ARCHIVED, DELETED }
enum ScheduledPostStatus { SCHEDULED, PUBLISHED, FAILED, CANCELLED }

# ===================================================================
# 2. CORE DOMAIN (Entities, Venues, Series)
# ===================================================================

type Entity @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  entityName: String! @index(name: "byEntityName")
  gameUrlDomain: String!
  gameUrlPath: String!
  entityLogo: AWSURL
  isActive: Boolean! @default(value: "true")
  defaultVenueId: ID
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  
  # Relationships
  scraperStates: [ScraperState] @hasMany(indexName: "byEntityScraperState", fields: ["id"])
  scraperJobs: [ScraperJob] @hasMany(indexName: "byEntityScraperJob", fields: ["id"])
  scrapeURLs: [ScrapeURL] @hasMany(indexName: "byEntityScrapeURL", fields: ["id"])
  venues: [Venue] @hasMany(indexName: "byEntityVenue", fields: ["id"])
  games: [Game] @hasMany(indexName: "byEntityGame", fields: ["id"])
  assets: [Asset] @hasMany(indexName: "byEntityAsset", fields: ["id"])
  
  # Social Pulse Relationships
  socialAccounts: [SocialAccount] @hasMany(indexName: "bySocialAccountEntity", fields: ["id"])
}

type Venue @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  venueNumber: Int! @index(name: "byVenueNumber", sortKeyFields: ["name"])
  name: String!
  aliases: [String]
  address: String
  city: String
  country: String
  fee: Float
  isSpecial: Boolean @default(value: "false")
  details: VenueDetails @hasOne
  
  # Relationships
  assets: [Asset] @hasMany(indexName: "byVenue", fields: ["id"])
  games: [Game] @hasMany(indexName: "byVenue", fields: ["id"])
  series: [TournamentSeries] @hasMany(indexName: "byVenue", fields: ["id"])
  playerMemberships: [PlayerVenue] @hasMany(indexName: "byVenue", fields: ["id"])
  registeredPlayers: [Player] @hasMany(indexName: "byRegistrationVenue", fields: ["id"])
  
  # Social Pulse Relationships
  socialAccounts: [SocialAccount] @hasMany(indexName: "bySocialAccountVenue", fields: ["id"])
  
  entityId: ID @index(name: "byEntityVenue", sortKeyFields: ["name"])
  entity: Entity @belongsTo(fields: ["entityId"])
}

type VenueDetails @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  startDate: AWSDateTime!
  status: VenueStatus!
  lastCustomerSuccessVisit: AWSDateTime
  totalGamesHeld: Int
  averagePlayersPerGame: Float
  gameNights: [String]
  venueId: ID! @index(name: "byVenue")
  venue: Venue @belongsTo(fields: ["venueId"])
}

type TournamentSeriesTitle @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  title: String!
  aliases: [String]
  seriesCategory: SeriesCategory
  seriesInstances: [TournamentSeries] @hasMany(indexName: "byTournamentSeriesTitle", fields: ["id"])
}

type TournamentSeries @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String! @index(name: "byName", sortKeyFields: ["year"])
  year: Int! @index(name: "byYear", sortKeyFields: ["name"])
  quarter: Int @index(name: "byQuarter", sortKeyFields: ["year"])
  month: Int @index(name: "byMonth", sortKeyFields: ["year"])
  seriesCategory: SeriesCategory! @default(value: "REGULAR") @index(name: "bySeriesCategory", sortKeyFields: ["year"])
  holidayType: HolidayType @index(name: "byHolidayType", sortKeyFields: ["year"])
  status: SeriesStatus!
  startDate: AWSDateTime
  endDate: AWSDateTime
  events: [String]
  numberOfEvents: Int
  guaranteedPrizepool: Float
  estimatedPrizepool: Float
  actualPrizepool: Float
  
  # Relationships
  tournamentSeriesTitleId: ID! @index(name: "byTournamentSeriesTitle", sortKeyFields: ["year"])
  title: TournamentSeriesTitle @belongsTo(fields: ["tournamentSeriesTitleId"])
  venueId: ID @index(name: "byVenue")
  venue: Venue @belongsTo(fields: ["venueId"])
  games: [Game] @hasMany(indexName: "byTournamentSeries", fields: ["id"])
}

# ===================================================================
# 3. GAME DOMAIN & CONSOLIDATION
# ===================================================================

type Game @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  # --- Core Identification ---
  id: ID!
  name: String!
  gameType: GameType!
  gameVariant: GameVariant!
  gameStatus: GameStatus! @index(name: "byStatus", queryField: "gamesByStatus", sortKeyFields: ["gameStartDateTime"])

  # --- Scheduling & Timestamps ---
  gameStartDateTime: AWSDateTime!
  gameEndDateTime: AWSDateTime
  registrationStatus: RegistrationStatus @index(name: "byRegistrationStatus", queryField: "gamesByRegistrationStatus", sortKeyFields: ["gameStartDateTime"])
  totalDuration: String
  gameFrequency: GameFrequency

  # --- Financials & Buy-in ---
  buyIn: Float
  rake: Float
  venueFee: Float
  startingStack: Int
  hasGuarantee: Boolean
  guaranteeAmount: Float

  # --- Aggregates & Results ---
  prizepool: Float
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int

  # --- Calculated Financial Metrics ---
  revenueByBuyIns: Float
  totalRake: Float
  profitLoss: Float
  guaranteeOverlay: Float
  guaranteeSurplus: Float

  # --- Live Game Data ---
  playersRemaining: Int
  totalChipsInPlay: Float
  averagePlayerStack: Float

  # --- Categorization & Metadata ---
  tournamentType: TournamentType
  isRegular: Boolean
  isSatellite: Boolean
  gameTags: [String]

  # --- Series Reference Fields ---
  isSeries: Boolean
  seriesName: String
  isMainEvent: Boolean
  eventNumber: Int
  dayNumber: Int
  flightLetter: String
  finalDay: Boolean

  # --- Multi-Day Consolidation Fields ---
  parentGameId: ID @index(name: "byParentGame", sortKeyFields: ["gameStartDateTime"])
  parentGame: Game @belongsTo(fields: ["parentGameId"])
  childGames: [Game] @hasMany(indexName: "byParentGame", fields: ["id"])
  
  consolidationType: String @default(value: "STANDARD") @index(name: "byConsolidationType", sortKeyFields: ["gameStartDateTime"])
  consolidationKey: String @index(name: "byConsolidationKey", queryField: "gamesByConsolidationKey")

  # --- Data Confidence ---
  isPartialData: Boolean @default(value: "false")
  missingFlightCount: Int
  expectedTotalEntries: Int
  actualCalculatedEntries: Int

  # --- Data Source ---
  sourceUrl: AWSURL @index(name: "bySourceUrl", queryField: "gameBySourceUrl")
  tournamentId: Int
  originalScrapedData: AWSJSON
  
  # --- Edit Tracking ---
  wasEdited: Boolean @default(value: "false")
  lastEditedAt: AWSDateTime
  lastEditedBy: String
  editHistory: AWSJSON

  # --- Venue & Series Tracking ---
  venueAssignmentStatus: VenueAssignmentStatus @default(value: "PENDING_ASSIGNMENT")
  requiresVenueAssignment: Boolean @default(value: "false")
  suggestedVenueName: String
  venueAssignmentConfidence: Float
  
  seriesAssignmentStatus: SeriesAssignmentStatus @default(value: "NOT_SERIES")
  seriesAssignmentConfidence: Float
  suggestedSeriesName: String

  # --- Structure Data ---
  levels: AWSJSON

  # --- Relationships ---
  venueId: ID @index(name: "byVenue", sortKeyFields: ["gameStartDateTime"])
  venue: Venue @belongsTo(fields: ["venueId"])
  tournamentSeriesId: ID @index(name: "byTournamentSeries", sortKeyFields: ["gameStartDateTime"])
  tournamentSeries: TournamentSeries @belongsTo(fields: ["tournamentSeriesId"])
  structure: TournamentStructure @hasOne
  gameCost: GameCost @hasOne(fields: ["id"])
  playerEntries: [PlayerEntry] @hasMany(indexName: "byGame", fields: ["id"])
  playerResults: [PlayerResult] @hasMany(indexName: "byGame", fields: ["id"])
  
  # Social Pulse Relationships
  linkedSocialPosts: [SocialPost] @hasMany(indexName: "bySocialPostGame", fields: ["id"])
  
  entityId: ID @index(name: "byEntityGame", sortKeyFields: ["gameStartDateTime"])
             @index(name: "byEntityAndTournamentId", sortKeyFields: ["tournamentId"], queryField: "gamesByEntityAndTournamentId")
  entity: Entity @belongsTo(fields: ["entityId"])

  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type TournamentStructure @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  levels: [TournamentLevel!]
  breaks: [Break!]
  gameId: ID! @index(name: "byGame")
  game: Game @belongsTo(fields: ["gameId"])
}

type TournamentLevelData @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  levels: [TournamentLevel!]
  gameId: ID! @index(name: "byGame")
}

type CashStructure @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  stakes: String!
  minBuyIn: Float
  maxBuyIn: Float
  gameId: ID! @index(name: "byGame")
}

type RakeStructure @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  rakePercentage: Float
  rakeCap: Float
  gameId: ID! @index(name: "byGame")
}

type GameCost @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  gameId: ID! @index(name: "byGameCost")
  game: Game @belongsTo(fields: ["gameId"]) 
  
  totalDealerCost: Float @default(value: "0")
  totalTournamentDirectorCost: Float @default(value: "0")
  totalPrizeContribution: Float @default(value: "0")
  totalJackpotContribution: Float @default(value: "0")
  totalPromotionCost: Float @default(value: "0")
  totalFloorStaffCost: Float @default(value: "0")
  totalOtherCost: Float @default(value: "0")
  totalCost: Float! @default(value: "0")
  
  lineItems: [GameCostLineItem] @hasMany(indexName: "byGameCost", fields: ["id"])
  
  entityId: ID @index(name: "byEntityCost", sortKeyFields: ["gameDate"])
  venueId: ID @index(name: "byVenueCost", sortKeyFields: ["gameDate"])
  gameDate: AWSDateTime @index(name: "byGameDateCost", sortKeyFields: ["totalCost"])
  
  notes: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type GameCostLineItem @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  gameCostId: ID! @index(name: "byGameCost")
  gameCost: GameCost @belongsTo(fields: ["gameCostId"])
  
  costItemId: ID! @index(name: "byCostItem")
  costItem: GameCostItem @belongsTo(fields: ["costItemId"])
  costType: CostItemType! @index(name: "byCostTypeLine", sortKeyFields: ["gameDate"])
  
  amount: Float!
  quantity: Float @default(value: "1")
  rate: Float
  hours: Float
  notes: String
  
  gameId: ID @index(name: "byGameLineItem")
  entityId: ID @index(name: "byEntityLineItem", sortKeyFields: ["gameDate"])
  venueId: ID @index(name: "byVenueLineItem", sortKeyFields: ["gameDate"])
  gameDate: AWSDateTime
  
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type GameCostItem @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  costType: CostItemType! @index(name: "byCostType", sortKeyFields: ["name"])
  rateType: CostItemRateType
  defaultRate: Float
  isPerHour: Boolean @default(value: "false")
  isActive: Boolean @default(value: "true")
  description: String
  lineItems: [GameCostLineItem] @hasMany(indexName: "byCostItem", fields: ["id"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# --- Game Consolidation Preview Types ---

type ConsolidationPreviewResult {
  willConsolidate: Boolean!
  reason: String!
  consolidation: ConsolidationDetails
  warnings: [String!]
  detectedPattern: DetectedMultiDayPattern
}

type ConsolidationDetails {
  consolidationKey: String!
  keyStrategy: String!
  parentExists: Boolean!
  parentGameId: ID
  parentName: String!
  siblingCount: Int!
  siblings: [ConsolidationSibling!]
  projectedTotals: ProjectedConsolidationTotals
}

type ConsolidationSibling {
  id: ID!
  name: String!
  dayNumber: Int
  flightLetter: String
  gameStatus: GameStatus
  gameStartDateTime: AWSDateTime
  totalEntries: Int
  finalDay: Boolean
}

type ProjectedConsolidationTotals {
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  prizepool: Float
  earliestStart: AWSDateTime
  latestEnd: AWSDateTime
  projectedStatus: GameStatus
  isPartialData: Boolean
  missingFlightCount: Int
}

type DetectedMultiDayPattern {
  isMultiDay: Boolean!
  detectionSource: String
  parsedDayNumber: Int
  parsedFlightLetter: String
  isFinalDay: Boolean
  derivedParentName: String!
}

# ===================================================================
# 4. PLAYER DOMAIN
# ===================================================================

type Player @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  primaryEntityId: ID @index(name: "byPrimaryEntity")
  firstName: String!
  lastName: String!
  phone: String @index(name: "byPhone", queryField: "playerByPhone")
  email: String @index(name: "byEmail", queryField: "playerByEmail")
  status: PlayerAccountStatus!
  category: PlayerAccountCategory!
  targetingClassification: PlayerTargetingClassification!
  registrationDate: AWSDateTime!
  firstGamePlayed: AWSDateTime
  lastPlayedDate: AWSDateTime
  creditBalance: Int
  pointsBalance: Int

  playerSummary: PlayerSummary @hasOne(fields: ["id"])
  knownIdentities: [KnownPlayerIdentity] @hasMany(indexName: "byPlayer", fields: ["id"])
  marketingPreferences: PlayerMarketingPreferences @hasOne(fields: ["id"])
  marketingMessages: [PlayerMarketingMessage] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerVenues: [PlayerVenue] @hasMany(indexName: "byVenue", fields: ["id"])
  playerEntries: [PlayerEntry] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerResults: [PlayerResult] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerTickets: [PlayerTicket] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerTransactions: [PlayerTransaction] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerCredits: [PlayerCredits] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerPoints: [PlayerPoints] @hasMany(indexName: "byPlayer", fields: ["id"])

  venueAssignmentStatus: VenueAssignmentStatus @default(value: "PENDING_ASSIGNMENT")
  registrationVenueId: ID @index(name: "byRegistrationVenue")
  registrationVenue: Venue @belongsTo(fields: ["registrationVenueId"])
  updatedAt: AWSDateTime!
}

type PlayerSummary @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  playerId: ID! @index(name: "byPlayer")
  gamesPlayedLast30Days: Int
  gamesPlayedLast90Days: Int
  gamesPlayedAllTime: Int
  averageFinishPosition: Float
  netBalance: Float
  player: Player @belongsTo(fields: ["playerId"])
  sessionsPlayed: Int
  tournamentsPlayed: Int
  cashGamesPlayed: Int
  venuesVisited: Int
  tournamentWinnings: Float
  tournamentBuyIns: Float
  tournamentITM: Int
  tournamentsCashed: Int
  cashGameWinnings: Float
  cashGameBuyIns: Float
  totalWinnings: Float
  totalBuyIns: Float
  lastPlayed: AWSDateTime!
}

type PlayerEntry @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["gameStartDateTime"])
  gameId: ID! @index(name: "byGame")
  venueId: ID @index(name: "byVenue")
  status: PlayerEntryStatus!
  registrationTime: AWSDateTime!
  eliminationTime: AWSDateTime
  gameStartDateTime: AWSDateTime!
  lastKnownStackSize: Int
  tableNumber: Int
  seatNumber: Int
  numberOfReEntries: Int
  isMultiDayTournament: Boolean
  player: Player @belongsTo(fields: ["playerId"])
  game: Game @belongsTo(fields: ["gameId"])
  
  entryType: EntryType @default(value: "INITIAL")
  qualifyingGameId: ID
  recordType: String @default(value: "ORIGINAL") @index(name: "byRecordType", sortKeyFields: ["gameStartDateTime"])
}

type PlayerResult @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  finishingPlace: Int
  isMultiDayQualification: Boolean
  prizeWon: Boolean
  amountWon: Float
  totalRunners: Int
  pointsEarned: Float
  gameStartDateTime: AWSDateTime!
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["gameStartDateTime"])
  player: Player @belongsTo(fields: ["playerId"])
  gameId: ID! @index(name: "byGame")
  game: Game @belongsTo(fields: ["gameId"])
  recordType: String @default(value: "ORIGINAL") @index(name: "byRecordTypeResult", sortKeyFields: ["gameStartDateTime"])
}

type PlayerVenue @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  totalGamesPlayed: Int
  averageBuyIn: Float
  firstPlayedDate: AWSDateTime
  lastPlayedDate: AWSDateTime
  targetingClassification: PlayerVenueTargetingClassification!
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["venueId"])
  player: Player @belongsTo(fields: ["playerId"])
  venueId: ID! @index(name: "byVenue", sortKeyFields: ["playerId"])
  venue: Venue @belongsTo(fields: ["venueId"])
}

type PlayerTransaction @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  type: TransactionType!
  amount: Float!
  rake: Float
  paymentSource: PaymentSourceType!
  transactionDate: AWSDateTime!
  notes: String
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["transactionDate"])
  player: Player @belongsTo(fields: ["playerId"])
  gameId: ID @index(name: "byGame")
}

type PlayerCredits @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  type: CreditTransactionType!
  changeAmount: Float!
  balanceAfter: Float!
  transactionDate: AWSDateTime!
  reason: String
  expiryDate: AWSDateTime
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["transactionDate"])
  player: Player @belongsTo(fields: ["playerId"])
  relatedGameId: ID @index(name: "byGame")
  relatedTransactionId: ID
}

type PlayerPoints @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  type: PointsTransactionType!
  changeAmount: Float!
  balanceAfter: Float!
  transactionDate: AWSDateTime!
  reason: String
  expiryDate: AWSDateTime
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["transactionDate"])
  player: Player @belongsTo(fields: ["playerId"])
  relatedGameId: ID @index(name: "byGame")
  relatedTransactionId: ID
}

type KnownPlayerIdentity @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  sourceSystem: String!
  identityValue: String!
  identityType: String!
  playerId: ID! @index(name: "byPlayer")
  player: Player @belongsTo(fields: ["playerId"])
}

# ===================================================================
# 5. SCRAPER & INGESTION ENGINE
# ===================================================================

type ScraperJob @model(queries: { list: null }) @auth(rules: [{ allow: private }]) {
  id: ID!
  jobId: String! @index(name: "byJobId")
  triggerSource: ScraperJobTriggerSource!
  triggeredBy: String
  startTime: AWSDateTime!
  endTime: AWSDateTime
  durationSeconds: Int
  maxGames: Int
  targetURLs: [String]
  isFullScan: Boolean
  startId: Int
  endId: Int
  status: ScraperJobStatus! @index(name: "byStatus", sortKeyFields: ["startTime"])
  totalURLsProcessed: Int
  newGamesScraped: Int
  gamesUpdated: Int
  gamesSkipped: Int
  errors: Int
  blanks: Int
  averageScrapingTime: Float
  successRate: Float
  errorMessages: [String]
  failedURLs: [String]
  urlResults: [ScraperJobURLResult]
  scrapeAttempts: [ScrapeAttempt] @hasMany(indexName: "byScraperJob", fields: ["id"])
  entityId: ID @index(name: "byEntityScraperJob", sortKeyFields: ["startTime"])
  entity: Entity @belongsTo(fields: ["entityId"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type ScrapeURL @model(queries: { get: "getScrapeURL", list: null }) @auth(rules: [{ allow: private }]) {
  id: ID!
  url: AWSURL! @index(name: "byURL", queryField: "scrapeURLByURL")
  tournamentId: Int! @index(name: "byTournamentId")
  doNotScrape: Boolean!
  sourceDataIssue: Boolean
  gameDataVerified: Boolean
  missingKeysFromScrape: [String]
  sourceSystem: String @index(name: "bySourceSystem", queryField: "scrapeURLsBySourceSystem", sortKeyFields: ["tournamentId"])
  status: ScrapeURLStatus!
  placedIntoDatabase: Boolean!
  firstScrapedAt: AWSDateTime!
  lastScrapedAt: AWSDateTime!
  lastSuccessfulScrapeAt: AWSDateTime
  timesScraped: Int!
  timesSuccessful: Int!
  timesFailed: Int!
  consecutiveFailures: Int @default(value: "0")
  lastScrapeStatus: ScrapeAttemptStatus
  lastScrapeMessage: String
  lastScrapeJobId: String
  gameId: ID @index(name: "byGameId")
  gameName: String
  gameStatus: GameStatus
  venueId: ID
  venueName: String
  lastDataHash: String
  hasDataChanges: Boolean
  lastFoundKeys: [String]
  lastStructureLabel: String
  averageScrapingTime: Float
  lastScrapingTime: Float
  attempts: [ScrapeAttempt] @hasMany(indexName: "byScrapeURL", fields: ["id"])
  entityId: ID @index(name: "byEntityScrapeURL")
  entity: Entity @belongsTo(fields: ["entityId"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  
  etag: String
  lastModifiedHeader: String
  contentHash: String
  s3StoragePrefix: String
  latestS3Key: String
  s3StorageEnabled: Boolean @default(value: "true")
  lastContentChangeAt: AWSDateTime
  totalContentChanges: Int @default(value: "0")
  lastHeaderCheckAt: AWSDateTime
  cachedContentUsedCount: Int @default(value: "0")
  lastCacheHitAt: AWSDateTime
  contentSize: Int
  wasEdited: Boolean @default(value: "false")
}

type ScrapeAttempt @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  url: AWSURL!
  tournamentId: Int!
  attemptTime: AWSDateTime!
  scraperJobId: ID! @index(name: "byScraperJob", sortKeyFields: ["attemptTime"])
  scraperJob: ScraperJob @belongsTo(fields: ["scraperJobId"])
  scrapeURLId: ID! @index(name: "byScrapeURL", sortKeyFields: ["attemptTime"])
  scrapeURL: ScrapeURL @belongsTo(fields: ["scrapeURLId"])
  status: ScrapeAttemptStatus!
  processingTime: Float
  gameName: String
  gameStatus: GameStatus
  registrationStatus: RegistrationStatus
  dataHash: String
  hasChanges: Boolean
  errorMessage: String
  errorType: String
  gameId: ID
  wasNewGame: Boolean
  fieldsUpdated: [String]
  foundKeys: [String]
  structureLabel: String
  wasEdited: Boolean @default(value: "false")
  scrapedAt: AWSDateTime
  fieldsExtracted: [String]
  entityId: ID
  contentHash: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type ScraperState @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  isRunning: Boolean!
  lastScannedId: Int!
  lastRunStartTime: AWSDateTime
  lastRunEndTime: AWSDateTime
  consecutiveBlankCount: Int!
  totalScraped: Int!
  totalErrors: Int!
  enabled: Boolean!
  currentLog: [ScraperLogData]
  highestStoredId: Int
  lowestStoredId: Int
  knownGapRanges: AWSJSON
  lastGapScanAt: AWSDateTime
  totalGamesInDatabase: Int
  lastGamesProcessed: [ScrapedGameStatus]
  entityId: ID @index(name: "byEntityScraperState")
  entity: Entity @belongsTo(fields: ["entityId"])
}

type ScrapeStructure @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  fields: [String]!
  structureLabel: String!
  occurrenceCount: Int!
  firstSeenAt: AWSDateTime!
  lastSeenAt: AWSDateTime!
  exampleUrl: AWSURL
}

type DataSync @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  syncedAt: AWSDateTime!
  method: DataSource!
  sourceUrl: AWSURL
  title: String
  content: String
}

type S3Storage @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  scrapeURLId: ID @index(name: "byScrapeURL", sortKeyFields: ["scrapedAt"])
  url: AWSURL! @index(name: "byURL", sortKeyFields: ["scrapedAt"])
  tournamentId: Int! @index(name: "byTournamentId", sortKeyFields: ["scrapedAt"])
  entityId: ID! @index(name: "byEntity", sortKeyFields: ["scrapedAt"])
  s3Key: String! @index(name: "byS3Key")
  s3Bucket: String!
  scrapedAt: AWSDateTime!
  contentSize: Int
  contentHash: String
  etag: String
  lastModified: String
  headers: AWSJSON
  dataExtracted: Boolean @default(value: "false")
  gameId: ID @index(name: "byGameId")
  isManualUpload: Boolean @default(value: "false")
  uploadedBy: String
  notes: String
  previousVersions: [S3VersionHistory]
  gameStatus: String @index(name: "byS3GameStatus", queryField: "s3StorageByGameStatus", sortKeyFields: ["scrapedAt"])
  registrationStatus: String @index(name: "byS3RegistrationStatus", queryField: "s3StorageByRegistrationStatus", sortKeyFields: ["scrapedAt"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  
  isParsed: Boolean @default(value: "false")
  parsedDataHash: String
  extractedFields: [String]
  lastParsedAt: AWSDateTime
  parseCount: Int @default(value: "0")
  rescrapeCount: Int @default(value: "0")
  lastRescrapeAt: AWSDateTime
  dataChangedAt: AWSDateTime
  dataChangeCount: Int @default(value: "0")
}

# ===================================================================
# 6. SYSTEM, ADMIN & ASSETS
# ===================================================================

type User @model(subscriptions: null) @auth(rules: [
  { allow: owner, ownerField: "id", operations: [read, update] },
  { allow: private, operations: [create, read] },
  { allow: groups, groups: ["SUPER_ADMIN"], operations: [create, read, update, delete] }
]) {
  id: ID!
  username: String!
  email: String!
  role: UserRole!
  preferences: [UserPreference] @hasMany(indexName: "byUser", fields: ["id"])
}

type UserPreference @model(subscriptions: null) @auth(rules: [{ allow: owner, ownerField: "userId" }]) {
  id: ID!
  page: String!
  widget: String!
  preference: AWSJSON
  userId: ID! @index(name: "byUser")
}

type Staff @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  firstName: String!
  lastName: String
  role: StaffRole!
  assignedVenueId: ID @index(name: "byVenue")
}

type Asset @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  type: String!
  condition: AssetCondition!
  acquiredDate: AWSDateTime!
  lastCheckedDate: AWSDateTime!
  venueId: ID! @index(name: "byVenue")
  venue: Venue @belongsTo(fields: ["venueId"])
  entityId: ID @index(name: "byEntityAsset", sortKeyFields: ["type"])
  entity: Entity @belongsTo(fields: ["entityId"])
}

type TicketTemplate @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  description: String
  value: Float!
  validityDays: Int!
  originGameId: ID
  targetGameId: ID
  playerTickets: [PlayerTicket] @hasMany(indexName: "byTicketTemplate", fields: ["id"])
}

type PlayerTicket @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  assignedAt: AWSDateTime!
  expiryDate: AWSDateTime!
  status: TicketStatus!
  usedInGameId: ID
  playerId: ID! @index(name: "byPlayer")
  player: Player @belongsTo(fields: ["playerId"])
  ticketTemplateId: ID! @index(name: "byTicketTemplate")
  ticketTemplate: TicketTemplate @belongsTo(fields: ["ticketTemplateId"])
}

type MarketingMessage @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  subject: String
  emailBody: String
  smsBody: String
  sentMessages: [PlayerMarketingMessage] @hasMany(indexName: "byMarketingMessage", fields: ["id"])
}

type PlayerMarketingMessage @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  status: MessageStatus!
  sentAt: AWSDateTime!
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["sentAt"])
  marketingMessageId: ID! @index(name: "byMarketingMessage")
}

type PlayerMarketingPreferences @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  optOutSms: Boolean
  optOutEmail: Boolean
  playerId: ID! @index(name: "byPlayer")
  player: Player @belongsTo(fields: ["playerId"])
}

# ===================================================================
# 6.5 SOCIAL PULSE
# ===================================================================

type SocialAccount @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  
  # --- Platform Identification ---
  platform: SocialPlatform!
  platformAccountId: String! @index(name: "byPlatformAccountId", queryField: "socialAccountByPlatformId")
  accountName: String! @index(name: "byAccountName")
  accountHandle: String
  accountUrl: AWSURL!
  
  # --- Account Metadata ---
  profileImageUrl: AWSURL
  coverImageUrl: AWSURL
  bio: String
  followerCount: Int
  followingCount: Int
  postCount: Int
  
  # --- Page Info (from Facebook API) ---
  hasFullHistory: Boolean @default(value: "false")
  pageDescription: String
  category: String
  website: String

  # --- Scraping Configuration ---
  status: SocialAccountStatus! @default(value: "PENDING_VERIFICATION")
  isScrapingEnabled: Boolean! @default(value: "true")
  scrapeFrequencyMinutes: Int @default(value: "60")
  lastScrapedAt: AWSDateTime
  lastSuccessfulScrapeAt: AWSDateTime
  nextScheduledScrapeAt: AWSDateTime
  consecutiveFailures: Int @default(value: "0")
  lastErrorMessage: String
  
  # --- Access Configuration (for future automated posting) ---
  hasPostAccess: Boolean @default(value: "false")
  accessTokenExpiry: AWSDateTime
  permissionsGranted: [String]
  
  # --- Relationships ---
  entityId: ID @index(name: "bySocialAccountEntity")
  entity: Entity @belongsTo(fields: ["entityId"])
  
  venueId: ID @index(name: "bySocialAccountVenue")
  venue: Venue @belongsTo(fields: ["venueId"])
  
  posts: [SocialPost] @hasMany(indexName: "bySocialAccount", fields: ["id"])
  scrapeAttempts: [SocialScrapeAttempt] @hasMany(indexName: "bySocialAccountAttempt", fields: ["id"])
  
  # --- Timestamps ---
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  createdBy: String
}

type SocialPost @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  
  # --- Post Identification ---
  platformPostId: String! @index(name: "byPlatformPostId", queryField: "socialPostByPlatformId")
  postUrl: AWSURL
  postType: SocialPostType!
  
  # --- Denormalized Account Info (for fast display without joins) ---
  accountName: String
  accountProfileImageUrl: String
  platform: String

  # --- Content ---
  content: String
  contentPreview: String
  rawContent: AWSJSON
  
  # --- Media ---
  mediaUrls: [AWSURL]
  thumbnailUrl: AWSURL
  mediaType: String
  
  # --- Engagement Metrics ---
  likeCount: Int @default(value: "0")
  commentCount: Int @default(value: "0")
  shareCount: Int @default(value: "0")
  reactionCount: Int @default(value: "0")
  viewCount: Int
  
  # --- Temporal Data ---
  postedAt: AWSDateTime! @index(name: "byPostedAt", sortKeyFields: ["likeCount"])
  scrapedAt: AWSDateTime!
  lastUpdatedAt: AWSDateTime
  
  # --- Status & Visibility ---
  status: SocialPostStatus! @default(value: "ACTIVE") @index(name: "byPostStatus", sortKeyFields: ["postedAt"])
  isPromotional: Boolean @default(value: "false")
  isPinned: Boolean @default(value: "false")
  isTournamentRelated: Boolean @default(value: "false")
  
  # --- Content Classification (for filtering) ---
  tags: [String]
  sentiment: String
  contentCategory: String
  
  # --- Linked Tournament (if post is about a specific game) ---
  linkedGameId: ID @index(name: "bySocialPostGame")
  linkedGame: Game @belongsTo(fields: ["linkedGameId"])
  
  # --- Relationships ---
  socialAccountId: ID! @index(name: "bySocialAccount", sortKeyFields: ["postedAt"])
  socialAccount: SocialAccount @belongsTo(fields: ["socialAccountId"])
  
  entityId: ID @index(name: "bySocialPostEntity", sortKeyFields: ["postedAt"])
  venueId: ID @index(name: "bySocialPostVenue", sortKeyFields: ["postedAt"])
  
  # --- Timestamps ---
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type SocialScrapeAttempt @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  
  # --- Attempt Details ---
  status: SocialScrapeStatus!
  startedAt: AWSDateTime!
  completedAt: AWSDateTime
  durationMs: Int
  
  # --- Sync Type ---
  syncType: String  # "INCREMENTAL" or "FULL_SYNC"
  
  # --- Results ---
  postsFound: Int @default(value: "0")
  newPostsAdded: Int @default(value: "0")
  postsUpdated: Int @default(value: "0")
  
  # --- Error Tracking ---
  errorMessage: String
  errorCode: String
  
  # --- Trigger Information ---
  triggerSource: ScraperJobTriggerSource
  triggeredBy: String
  
  # --- Relationships ---
  socialAccountId: ID! @index(name: "bySocialAccountAttempt", sortKeyFields: ["startedAt"])
  socialAccount: SocialAccount @belongsTo(fields: ["socialAccountId"])
  
  # --- Timestamps ---
  createdAt: AWSDateTime!
}

type SocialScheduledPost @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  
  # --- Post Content ---
  content: String!
  mediaUrls: [AWSURL]
  linkUrl: AWSURL
  
  # --- Scheduling ---
  scheduledFor: AWSDateTime! @index(name: "byScheduledTime")
  publishedAt: AWSDateTime
  status: ScheduledPostStatus! @default(value: "SCHEDULED") @index(name: "byScheduledPostStatus", sortKeyFields: ["scheduledFor"])
  
  # --- Target Accounts ---
  targetAccountIds: [ID!]!
  
  # --- Related Game (for tournament results posts) ---
  linkedGameId: ID @index(name: "byScheduledPostGame")
  templateType: String
  
  # --- Relationships ---
  entityId: ID! @index(name: "byScheduledPostEntity", sortKeyFields: ["scheduledFor"])
  createdBy: String!
  
  # --- Timestamps ---
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# ===================================================================
# 7. NON-MODEL TYPES & RESPONSES
# ===================================================================

# --- Scraper Types ---
type ScraperControlResponse {
  success: Boolean!
  message: String
  state: ScraperStateData
  results: ScraperResults
}

type ScraperStateData {
  id: String!
  isRunning: Boolean!
  lastScannedId: Int!
  lastRunStartTime: String
  lastRunEndTime: String
  consecutiveBlankCount: Int!
  totalScraped: Int!
  totalErrors: Int!
  enabled: Boolean!
  currentLog: [ScraperLogData]
  lastGamesProcessed: [ScrapedGameStatus]
  entityId: String
}

type ScraperResults {
  newGamesScraped: Int!
  gamesUpdated: Int!
  errors: Int!
  blanks: Int!
}

type ScraperLogData {
  timestamp: AWSDateTime!
  level: String!
  message: String!
  details: String
}

type ScrapedGameStatus {
  id: Int!
  name: String!
  status: String!
}

type ScraperJobURLResult {
  url: String!
  tournamentId: Int!
  status: ScrapeAttemptStatus!
  gameName: String
  processingTime: Float
  error: String
}

type ScraperMetrics {
  totalJobs: Int!
  successfulJobs: Int!
  failedJobs: Int!
  averageJobDuration: Float!
  totalURLsScraped: Int!
  successRate: Float!
  topErrors: [ErrorMetric!]
  hourlyActivity: [HourlyMetric!]
  byEntity: [EntityScraperMetrics]
}

type ErrorMetric {
  errorType: String!
  count: Int!
  urls: [String!]
}

type HourlyMetric {
  hour: String!
  jobCount: Int!
  urlsScraped: Int!
  successRate: Float!
}

type EntityScraperMetrics {
  entityId: ID
  entityName: String!
  totalJobs: Int!
  successfulJobs: Int!
  failedJobs: Int!
  totalURLsScraped: Int!
}

type ScrapedGameSummary {
  id: String!
  name: String
  gameStatus: String
  registrationStatus: String
  gameStartDateTime: String
  inDatabase: Boolean
  doNotScrape: Boolean
  error: String
}

type ScrapedGameData {
  name: String!
  gameStartDateTime: String
  gameEndDateTime: String
  gameStatus: GameStatus
  registrationStatus: String
  gameType: GameType
  gameVariant: GameVariant
  tournamentType: TournamentType
  prizepool: Float
  revenueByBuyIns: Float
  profitLoss: Float
  buyIn: Float
  rake: Float
  totalRake: Float
  startingStack: Int
  hasGuarantee: Boolean
  guaranteeAmount: Float
  guaranteeOverlay: Float
  guaranteeSurplus: Float
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  totalDuration: String
  playersRemaining: Int
  totalChipsInPlay: Float
  averagePlayerStack: Float
  seriesName: String
  isRegular: Boolean
  isSeries: Boolean
  isSatellite: Boolean
  tournamentSeriesId: ID
  seriesTitleId: ID
  isMainEvent: Boolean
  eventNumber: Int
  dayNumber: Int
  flightLetter: String
  finalDay: Boolean
  seriesYear: Int
  gameFrequency: GameFrequency
  gameTags: [String]
  levels: [ScrapedTournamentLevel!]
  breaks: [ScrapedBreak!]
  entries: [ScrapedPlayerEntry!]
  seating: [ScrapedPlayerSeating!]
  results: [ScrapedPlayerResult!]
  tables: [ScrapedTable!]
  rawHtml: String
  isNewStructure: Boolean
  structureLabel: String
  foundKeys: [String]
  venueMatch: ScrapedVenueMatch
  existingGameId: String
  doNotScrape: Boolean
  skipped: Boolean
  skipReason: String
  tournamentId: Int!
  entityId: ID
  sourceUrl: AWSURL
  s3Key: String
  source: String
  contentHash: String
  fetchedAt: AWSDateTime
  reScrapedAt: AWSDateTime
  wasForced: Boolean
}

type ScrapedTournamentLevel {
  levelNumber: Int!
  durationMinutes: Int
  smallBlind: Int
  bigBlind: Int
  ante: Int
}

type ScrapedBreak {
  levelNumberBeforeBreak: Int!
  durationMinutes: Int
}

type ScrapedPlayerEntry {
  name: String!
}

type ScrapedPlayerSeating {
  name: String!
  table: Int
  seat: Int
  playerStack: Int
}

type ScrapedPlayerResult {
  rank: Int!
  name: String!
  winnings: Float
  points: Float
  isQualification: Boolean
}

type ScrapedTable {
  tableName: String!
  seats: [ScrapedTableSeatData!]
}

type ScrapedTableSeatData {
  seat: Int!
  isOccupied: Boolean!
  playerName: String
  playerStack: Int
}

type ScrapedVenueMatch {
  autoAssignedVenue: ScrapedVenueMatchDetails
  suggestions: [ScrapedVenueMatchDetails!]
}

type ScrapedVenueMatchDetails {
  id: ID!
  name: String!
  score: Float!
}

type VenueMatch {
  autoAssignedVenue: ScrapedVenueMatchDetails
  suggestions: [ScrapedVenueMatchDetails]
}

type ReScrapeResult {
  name: String
  gameStartDateTime: AWSDateTime
  gameEndDateTime: AWSDateTime
  gameStatus: GameStatus
  registrationStatus: RegistrationStatus
  gameType: GameType
  gameVariant: GameVariant
  tournamentType: TournamentType
  prizepool: Float
  buyIn: Float
  rake: Float
  startingStack: Int
  hasGuarantee: Boolean
  guaranteeAmount: Float
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  totalDuration: String
  playersRemaining: Int
  seriesName: String
  gameTags: [String]
  venueMatch: VenueMatch
  existingGameId: ID
  doNotScrape: Boolean
  sourceUrl: AWSURL
  tournamentId: Int
  entityId: ID
  s3Key: String
  reScrapedAt: AWSDateTime
}

# --- Gap Detection Types ---
type GapRange {
  start: Int!
  end: Int!
  count: Int!
}

type EntityScrapingStatus {
  entityId: ID!
  entityName: String
  lowestTournamentId: Int
  highestTournamentId: Int
  totalGamesStored: Int!
  unfinishedGameCount: Int!
  gaps: [GapRange!]!
  gapSummary: GapSummary!
  lastUpdated: AWSDateTime!
  cacheAge: Int
}

type GapSummary {
  totalGaps: Int!
  totalMissingIds: Int!
  largestGapStart: Int
  largestGapEnd: Int
  largestGapCount: Int
  coveragePercentage: Float!
}

type TournamentIdBounds {
  entityId: ID!
  lowestId: Int
  highestId: Int
  totalCount: Int!
  lastUpdated: AWSDateTime!
}

# --- S3 & Caching Types ---
type S3VersionHistory {
  s3Key: String!
  scrapedAt: AWSDateTime!
  contentHash: String
  uploadedBy: String
  contentSize: Int
}

type CachingStatsResponse {
  totalURLs: Int!
  urlsWithETags: Int!
  urlsWithLastModified: Int!
  totalCacheHits: Int!
  totalCacheMisses: Int!
  averageCacheHitRate: Float!
  storageUsedMB: Float!
  recentCacheActivity: [CacheActivityLog!]
}

type CacheActivityLog {
  url: AWSURL!
  timestamp: AWSDateTime!
  action: String!
  reason: String
}

type S3ContentResponse {
  s3Key: String!
  html: String!
  metadata: AWSJSON
  size: Int
  lastModified: AWSDateTime
}

type S3StorageHistoryResponse {
  items: [S3Storage]
  nextToken: String
}

type S3StorageListResponse {
  items: [S3Storage]
  nextToken: String
}

# --- Structure Types ---
type TournamentLevel {
  levelNumber: Int!
  durationMinutes: Int
  smallBlind: Int
  bigBlind: Int
  ante: Int
}

type Break {
  levelNumberBeforeBreak: Int!
  durationMinutes: Int
}

# --- Metrics Types ---
type ClientMetricResponse {
  success: Boolean!
  message: String
  userId: String
}

type UserMetricsSummary {
  userId: String!
  userName: String
  totalActions: Int
  totalPageViews: Int
  totalErrors: Int
  lastActive: String
  mostUsedFeature: String
}

type DatabaseMetric {
  timestamp: AWSDateTime!
  functionName: String!
  operation: String!
  table: String!
  success: Boolean!
  duration: Float
  count: Int
  entityId: String
}

type DatabaseMetricsResponse {
  metrics: [DatabaseMetric!]!
}

type AllCountsResult {
  playerCount: Int
  playerSummaryCount: Int
  playerEntryCount: Int
  playerResultCount: Int
  playerVenueCount: Int
  playerTransactionCount: Int
  playerCreditsCount: Int
  playerPointsCount: Int
  playerTicketCount: Int
  playerMarketingPreferencesCount: Int
  playerMarketingMessageCount: Int
  gameCount: Int
  tournamentStructureCount: Int
}

# --- Venue Assignment Types ---
type EntityVenueAssignmentSummary {
  entityId: ID
  entityName: String!
  totalGames: Int
  gamesWithVenue: Int
  gamesNeedingVenue: Int
}

type VenueAssignmentSummary {
  totalGames: Int
  gamesWithVenue: Int
  gamesNeedingVenue: Int
  pendingAssignments: Int
  byEntity: [EntityVenueAssignmentSummary]
}

type VenueAssignmentResult {
  success: Boolean!
  gameId: ID!
  venueId: ID!
  affectedRecords: AffectedRecords
  error: String
}

type AffectedRecords {
  gameUpdated: Boolean
  playerEntriesUpdated: Int
  playerVenueRecordsCreated: Int
  playersWithRegistrationUpdated: Int
  playerSummariesUpdated: Int
}

type BatchVenueAssignmentResult {
  successful: [VenueAssignmentResult]
  failed: [VenueAssignmentResult]
  totalProcessed: Int
}

type GamesNeedingVenueResponse {
  items: [Game]
  nextToken: String
  totalCount: Int
}

# --- Social Pulse Response Types (CORRECTED) ---
type SocialFeedConnection {
  items: [SocialPost!]!
  nextToken: String
  totalCount: Int
}

type SocialPostConnection {
  items: [SocialPost!]!
  nextToken: String
}

type SocialAccountConnection {
  items: [SocialAccount!]!
  nextToken: String
}

type SocialAccountMetrics {
  accountId: ID!
  totalPosts: Int!
  totalEngagement: Int!
  avgLikesPerPost: Float
  avgCommentsPerPost: Float
  avgSharesPerPost: Float
  postsThisPeriod: Int
  engagementGrowth: Float
  topPerformingPosts: [SocialPost!]
}

# CORRECTED: Matches what the Lambda actually returns
type SocialScrapeResult {
  success: Boolean!
  message: String
  postsFound: Int
  newPostsAdded: Int
}

# CORRECTED: Matches what the Lambda actually returns  
type SyncPageInfoResult {
  success: Boolean!
  message: String
  logoUrl: String
}

# --- Misc Response Types ---
type RefreshResponse {
  message: String!
  status: String!
}

type SaveGameResult {
  success: Boolean!
  gameId: ID
  action: String!
  message: String
  warnings: [String]
  playerProcessingQueued: Boolean
  playerProcessingReason: String
  venueAssignment: SaveVenueAssignmentInfo
  seriesAssignment: SaveSeriesAssignmentInfo
  fieldsUpdated: [String]
  wasEdited: Boolean
}

type SaveVenueAssignmentInfo {
  venueId: ID
  venueName: String
  status: VenueAssignmentStatus
  confidence: Float
}

type SaveSeriesAssignmentInfo {
  tournamentSeriesId: ID
  seriesName: String
  status: SeriesAssignmentStatus
  confidence: Float
}

# --- Connection Types (Paginated) ---
type S3StorageConnection {
  items: [S3Storage!]!
  nextToken: String
}

type ScraperJobConnection {
  items: [ScraperJob!]
  nextToken: String
}

type ScrapeURLConnection {
  items: [ScrapeURL!]
  nextToken: String
}

type UnfinishedGamesConnection {
  items: [Game!]!
  nextToken: String
  totalCount: Int!
}

# ===================================================================
# 8. INPUT TYPES
# ===================================================================

input ConsolidationPreviewInput {
  gameData: GamePreviewDataInput!
  existingGameId: ID
  includeSiblingDetails: Boolean
}

input GamePreviewDataInput {
  name: String!
  tournamentId: Int
  venueId: ID
  entityId: ID
  buyIn: Float
  gameStatus: GameStatus
  gameStartDateTime: AWSDateTime
  tournamentSeriesId: ID
  eventNumber: Int
  dayNumber: Int
  flightLetter: String
  finalDay: Boolean
  isSeries: Boolean
  seriesName: String
  isMainEvent: Boolean
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  prizepool: Float
  gameEndDateTime: AWSDateTime
}

input ClientMetricInput {
  metricName: String!
  value: Float!
  unit: String!
  dimensions: String
  timestamp: String
  metadata: String
}

input ManualHTMLUploadInput {
  htmlContent: String!
  url: AWSURL!
  tournamentId: Int!
  entityId: ID!
  notes: String
  uploadedBy: String!
}

input ReScrapeFromCacheInput {
  s3Key: String!
  saveToDatabase: Boolean
}

input UploadManualHTMLInput {
  htmlContent: String!
  url: AWSURL!
  tournamentId: Int!
  entityId: ID!
  notes: String
  uploadedBy: String
}

input VenueAssignment {
  gameId: ID!
  venueId: ID!
}

input SaveTournamentInput {
  sourceUrl: AWSURL!
  venueId: ID
  existingGameId: ID
  doNotScrape: Boolean
  data: ScrapedGameDataInput!
  originalScrapedData: AWSJSON
  venueAssignmentStatus: VenueAssignmentStatus
  requiresVenueAssignment: Boolean
  suggestedVenueName: String
  venueAssignmentConfidence: Float
  entityId: ID
}

input ScrapedGameDataInput {
  name: String!
  gameStartDateTime: String
  gameEndDateTime: String
  gameStatus: GameStatus
  registrationStatus: RegistrationStatus
  gameVariant: GameVariant
  gameType: GameType
  prizepool: Float
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  totalDuration: String
  gameTags: [String]
  tournamentType: TournamentType
  buyIn: Float
  rake: Float
  startingStack: Int
  hasGuarantee: Boolean
  guaranteeAmount: Float
  levels: [ScrapedTournamentLevelInput!]
}

input ScrapedTournamentLevelInput {
  levelNumber: Int!
  durationMinutes: Int
  smallBlind: Int
  bigBlind: Int
  ante: Int
  breakMinutes: Int
}

input StartScraperJobInput {
  triggerSource: ScraperJobTriggerSource!
  maxGames: Int
  targetURLs: [String]
  startId: Int
  endId: Int
  isFullScan: Boolean
  triggeredBy: String
  entityId: ID
  isSequential: Boolean
}

input SaveGameInput {
  source: DataSourceInfoInput!
  game: SaveGameDataInput!
  players: SavePlayerDataInput
  venue: VenueReferenceInput
  series: SeriesReferenceInput
  options: SaveProcessingOptionsInput
  auditTrail: String
}

input DataSourceInfoInput {
  type: DataSource!
  sourceId: String!
  entityId: ID!
  fetchedAt: AWSDateTime!
  contentHash: String
  wasEdited: Boolean
}

input SaveGameDataInput {
  tournamentId: Int
  existingGameId: ID
  name: String!
  gameType: GameType!
  gameVariant: GameVariant
  gameStatus: GameStatus!
  gameStartDateTime: AWSDateTime!
  gameEndDateTime: AWSDateTime
  registrationStatus: RegistrationStatus
  gameFrequency: GameFrequency
  buyIn: Float
  rake: Float
  totalRake: Float
  guaranteeAmount: Float
  guaranteeOverlay: Float
  guaranteeSurplus: Float
  hasGuarantee: Boolean
  startingStack: Int
  prizepool: Float
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  playersRemaining: Int
  totalChipsInPlay: Float
  averagePlayerStack: Float
  totalDuration: String
  revenueByBuyIns: Float
  profitLoss: Float
  tournamentType: TournamentType
  isSeries: Boolean
  seriesName: String
  tournamentSeriesId: ID
  isMainEvent: Boolean
  eventNumber: Int
  dayNumber: Int
  flightLetter: String
  finalDay: Boolean
  isSatellite: Boolean
  isRegular: Boolean
  gameTags: [String]
  levels: AWSJSON
}

input SavePlayerDataInput {
  allPlayers: [SavePlayerInfoInput!]!
  totalPlayers: Int!
  hasCompleteResults: Boolean!
  totalPrizesPaid: Float
  hasEntryList: Boolean
  hasSeatingData: Boolean
}

input SavePlayerInfoInput {
  name: String!
  rank: Int
  winnings: Float
  points: Float
  isQualification: Boolean
  rebuys: Int
  addons: Int
}

input VenueReferenceInput {
  venueId: ID
  venueName: String
  suggestedVenueId: ID
  confidence: Float
}

input SeriesReferenceInput {
  seriesId: ID
  seriesName: String
  suggestedSeriesId: ID
  year: Int
  confidence: Float
  isMainEvent: Boolean
  eventNumber: Int
  dayNumber: Int
  flightLetter: String
  finalDay: Boolean
}

input SaveProcessingOptionsInput {
  skipPlayerProcessing: Boolean
  forceUpdate: Boolean
  validateOnly: Boolean
  doNotScrape: Boolean
  priority: String
}

# --- Social Pulse Input Types ---

input AddSocialAccountInput {
  platform: SocialPlatform!
  accountUrl: AWSURL!
  accountName: String!
  accountHandle: String
  platformAccountId: String
  entityId: ID
  venueId: ID
  scrapeFrequencyMinutes: Int
}

input UpdateSocialAccountInput {
  id: ID!
  accountName: String
  accountHandle: String
  isScrapingEnabled: Boolean
  scrapeFrequencyMinutes: Int
  status: SocialAccountStatus
  entityId: ID
  venueId: ID
  profileImageUrl: AWSURL
  bio: String
}

input SchedulePostInput {
  content: String!
  mediaUrls: [AWSURL]
  linkUrl: AWSURL
  scheduledFor: AWSDateTime!
  targetAccountIds: [ID!]!
  entityId: ID!
  linkedGameId: ID
  templateType: String
}

input UpdateSocialPostInput {
  id: ID!
  status: SocialPostStatus
  isTournamentRelated: Boolean
  linkedGameId: ID
  tags: [String]
  contentCategory: String
}

# ===================================================================
# 9. ROOT OPERATIONS
# ===================================================================

type Query {
  # --- Consolidation Queries ---
  previewConsolidation(input: ConsolidationPreviewInput!): ConsolidationPreviewResult! @function(name: "tournamentConsolidator-${env}")

  # --- Scraper & Jobs ---
  fetchTournamentDataRange(startId: Int!, endId: Int!): [ScrapedGameSummary!] @function(name: "webScraperFunction-${env}")
  getScraperControlState(entityId: ID): ScraperControlResponse @function(name: "autoScraper-${env}")
  fetchUpdateCandidates: [String!] @function(name: "webScraperFunction-${env}")
  getScraperJobsReport(status: ScraperJobStatus, limit: Int, nextToken: String): ScraperJobConnection @function(name: "scraperManagement-${env}")
  fetchScrapeURLDetails(url: AWSURL!): ScrapeURL @function(name: "scraperManagement-${env}")
  searchScrapeURLs(status: ScrapeURLStatus, limit: Int, nextToken: String): ScrapeURLConnection @function(name: "scraperManagement-${env}")
  getScraperMetrics(timeRange: TimeRange!, entityId: ID): ScraperMetrics @function(name: "scraperManagement-${env}")
  getUpdateCandidateURLs(limit: Int): [ScrapeURL!] @function(name: "scraperManagement-${env}")
  scrapeGame(url: AWSURL!, entityId: ID, venueId: ID, doNotScrape: Boolean): ScrapedGameData @function(name: "singleGameScraper-${env}")
  scrapeBulkGames(startId: Int!, endId: Int!, entityId: ID): [ScrapedGameSummary] @function(name: "bulkGamesScraper-${env}")
  listScraperJobs(entityId: ID, status: ScraperJobStatus, startTime: AWSDateTime, endTime: AWSDateTime, limit: Int, nextToken: String): ScraperJobConnection @function(name: "scraperJobQuery-${env}")
  listScrapeURLs(entityId: ID, status: ScrapeURLStatus, limit: Int, nextToken: String): ScrapeURLConnection @function(name: "scrapeURLQuery-${env}")
  
  # --- Venue & Assignments ---
  listGamesNeedingVenue(limit: Int, nextToken: String, entityId: ID): GamesNeedingVenueResponse @function(name: "venueAssignmentService-${env}")  
  getVenueAssignmentSummary(entityId: ID): VenueAssignmentSummary @function(name: "venueAssignmentService-${env}")
  
  # --- Metrics ---
  getMyMetrics(timeRange: String): UserMetricsSummary @function(name: "getUserMetrics-${env}") @auth(rules: [{ allow: private }])
  getUserMetrics(userId: String!, timeRange: String): UserMetricsSummary @function(name: "getUserMetrics-${env}") @auth(rules: [{ allow: groups, groups: ["Admin"] }])
  getDatabaseMetrics(timeRange: String): DatabaseMetricsResponse @function(name: "getDatabaseMetrics-${env}")
  
  # --- Counts ---
  playerCount: Int @function(name: "getModelCount-${env}")
  playerSummaryCount: Int @function(name: "getModelCount-${env}")
  playerEntryCount: Int @function(name: "getModelCount-${env}")
  playerResultCount: Int @function(name: "getModelCount-${env}")
  playerVenueCount: Int @function(name: "getModelCount-${env}")
  playerTransactionCount: Int @function(name: "getModelCount-${env}")
  playerCreditsCount: Int @function(name: "getModelCount-${env}")
  playerPointsCount: Int @function(name: "getModelCount-${env}")
  playerTicketCount: Int @function(name: "getModelCount-${env}")
  playerMarketingPreferencesCount: Int @function(name: "getModelCount-${env}")
  playerMarketingMessageCount: Int @function(name: "getModelCount-${env}")
  gameCount: Int @function(name: "getModelCount-${env}")
  tournamentStructureCount: Int @function(name: "getModelCount-${env}")
  getAllCounts: AllCountsResult @function(name: "getModelCount-${env}")
  
  # --- S3 & Storage ---
  getS3StorageHistory(tournamentId: Int!, entityId: ID!, limit: Int): S3StorageConnection @function(name: "s3ManagementFunction-${env}")
  viewS3Content(s3Key: String!): S3ContentResponse @function(name: "s3ManagementFunction-${env}")
  getCachingStats(entityId: ID!, timeRange: TimeRange): CachingStatsResponse @function(name: "s3ManagementFunction-${env}")
  listStoredHTML(url: AWSURL!, limit: Int): S3StorageConnection @function(name: "s3ManagementFunction-${env}")
  
  # --- Game Tracker & Gaps ---
  getTournamentIdBounds(entityId: ID!): TournamentIdBounds @function(name: "gameIdTracker-${env}")
  getEntityScrapingStatus(entityId: ID!, forceRefresh: Boolean, startId: Int, endId: Int): EntityScrapingStatus @function(name: "gameIdTracker-${env}")
  findTournamentIdGaps(entityId: ID!, startId: Int, endId: Int, maxGapsToReturn: Int): [GapRange!] @function(name: "gameIdTracker-${env}")
  getUnfinishedGamesByEntity(entityId: ID!, limit: Int, nextToken: String): UnfinishedGamesConnection @function(name: "gameIdTracker-${env}")
  listExistingTournamentIds(entityId: ID!, startId: Int, endId: Int, limit: Int): [Int!] @function(name: "gameIdTracker-${env}")
}

type Mutation {
  # --- Scraper Controls ---
  fetchTournamentData(url: AWSURL, s3Key: String, forceRefresh: Boolean, scraperApiKey: String): ScrapedGameData @function(name: "webScraperFunction-${env}")
  saveTournamentData(input: SaveTournamentInput!): Game @function(name: "webScraperFunction-${env}")
  controlScraperOperation(operation: ScraperOperation!, entityId: ID): ScraperControlResponse @function(name: "autoScraper-${env}")
  triggerAutoScraping(maxGames: Int): ScraperControlResponse @function(name: "autoScraper-${env}")
  startScraperJob(input: StartScraperJobInput!): ScraperJob @function(name: "scraperManagement-${env}")
  cancelScraperJob(jobId: String!): ScraperJob @function(name: "scraperManagement-${env}")
  modifyScrapeURLStatus(url: AWSURL!, status: ScrapeURLStatus, doNotScrape: Boolean): ScrapeURL @function(name: "scraperManagement-${env}")
  bulkModifyScrapeURLs(urls: [AWSURL!]!, status: ScrapeURLStatus, doNotScrape: Boolean): [ScrapeURL!] @function(name: "scraperManagement-${env}")
  reScrapeFromCache(input: ReScrapeFromCacheInput!): ScrapedGameData @function(name: "webScraperFunction-${env}")
  forceRefreshScrape(url: AWSURL!): ScrapedGameData
  clearURLCache(url: AWSURL!): Boolean
  saveGame(input: SaveGameInput!): SaveGameResult! @function(name: "saveGameFunction-${env}")

  # --- Venue Assignment ---
  assignVenueToGame(gameId: ID!, venueId: ID!): VenueAssignmentResult @function(name: "venueAssignmentService-${env}")
  batchAssignVenues(assignments: [VenueAssignment!]!): BatchVenueAssignmentResult @function(name: "venueAssignmentService-${env}")
  
  # --- Misc & S3 ---
  publishClientMetrics(metrics: [ClientMetricInput!]!): ClientMetricResponse @function(name: "publishClientMetrics-${env}") @auth(rules: [{ allow: private }])
  uploadManualHTML(input: ManualHTMLUploadInput!): S3Storage
  
  # --- Social Pulse Mutations ---
  triggerSocialScrape(socialAccountId: ID!): SocialScrapeResult @function(name: "socialFetcher-${env}")
  triggerFullSync(socialAccountId: ID!): SocialScrapeResult @function(name: "socialFetcher-${env}")
  syncPageInfo(socialAccountId: ID!): SyncPageInfoResult @function(name: "socialFetcher-${env}")
}

type Subscription {
  onScraperJobUpdate(jobId: String): ScraperJob @aws_subscribe(mutations: ["startScraperJob", "cancelScraperJob"])
  onScrapeURLStatusChange(url: AWSURL): ScrapeURL @aws_subscribe(mutations: ["modifyScrapeURLStatus", "bulkModifyScrapeURLs"])
}