# ===================================================================
# KINGSROOM SCHEMA
# Version: 1.0.4
# ===================================================================

# ===================================================================
# 1. ALL ENUMS
# ===================================================================

enum DataSource { SCRAPE, API, MANUAL }
enum AssetCondition { NEW, GOOD, FAIR, POOR, RETIRED }
enum VenueStatus { ACTIVE, INACTIVE, PENDING }
enum GameType { TOURNAMENT, CASH_GAME }
enum GameStatus { INITIATING, SCHEDULED, REGISTERING, RUNNING, CANCELLED, FINISHED, NOT_IN_USE, NOT_PUBLISHED, CLOCK_STOPPED, UNKNOWN }
enum GameVariant { NLHE, PLO, PLOM, PLO5, PLO6 }
enum GameFrequency { DAILY, WEEKLY, FORTNIGHTLY, MONTHLY, QUARTERLY, YEARLY, UNKNOWN }
enum RegistrationStatus { SCHEDULED, OPEN, FINAL, CLOSED, N_A }
enum TournamentType { FREEZEOUT, REBUY, SATELLITE, DEEPSTACK }
enum PaymentSourceType { CASH, SQUARE, CREDIT_CARD, INTERNAL_CREDIT, UNKNOWN }
enum PlayerAccountStatus { ACTIVE, SUSPENDED, PENDING_VERIFICATION }
enum PlayerAccountCategory { NEW, RECREATIONAL, REGULAR, VIP, LAPSED }
enum SeriesStatus { LIVE, SCHEDULED, COMPLETED }
enum PlayerTargetingClassification { NotPlayed, Active_EL, Active, Retain_Inactive31_60d, Retain_Inactive61_90d, Churned_91_120d, Churned_121_180d, Churned_181_360d, Churned_361d }
enum PlayerVenueTargetingClassification { Active_EL, Active, Retain_Inactive31_60d, Retain_Inactive61_90d, Churn_91_120d, Churn_121_180d, Churn_181_360d, Churn_361d }
enum TransactionType { BUY_IN, DEPOSIT, TICKET_AWARD, TICKET_REDEMPTION, CASH_AWARD, QUALIFICATION, WITHDRAWAL }
enum MessageStatus { SENT, DELIVERED, FAILED, READ }
enum UserRole { SUPER_ADMIN, ADMIN, VENUE_MANAGER, TOURNAMENT_DIRECTOR, MARKETING }
enum StaffRole { DEALER, FLOOR_MANAGER, SERVICE, TOURNAMENT_DIRECTOR }
enum TicketStatus { ACTIVE, EXPIRED, USED }
enum PlayerEntryStatus { REGISTERED, VOIDED, PLAYING, ELIMINATED, COMPLETED }
enum CreditTransactionType { AWARD_PROMOTION, AWARD_REFUND, AWARD_MANUAL, REDEEM_GAME_BUY_IN, EXPIRED }
enum PointsTransactionType { EARN_FROM_PLAY, EARN_FROM_PROMOTION, REDEEM_FOR_BUY_IN, REDEEM_FOR_MERCH, ADJUSTMENT_MANUAL, EXPIRED }

enum VenueAssignmentStatus {
  AUTO_ASSIGNED
  MANUALLY_ASSIGNED
  PENDING_ASSIGNMENT
  UNASSIGNED
  RETROACTIVE_ASSIGNED
}

enum ScraperJobTriggerSource { SCHEDULED, MANUAL, API, CONTROL, BULK, ADMIN }
enum ScraperJobStatus { QUEUED, RUNNING, COMPLETED, FAILED, CANCELLED, TIMEOUT }
enum ScrapeURLStatus { ACTIVE, INACTIVE, DO_NOT_SCRAPE, ERROR, ARCHIVED }
enum ScrapeAttemptStatus { SUCCESS, FAILED, SKIPPED_DONOTSCRAPE, SKIPPED_VENUE, BLANK, NO_CHANGES, UPDATED, SAVED }
enum TimeRange { LAST_HOUR, LAST_24_HOURS, LAST_7_DAYS, LAST_30_DAYS, CUSTOM }
enum ScraperOperation { START, STOP, ENABLE, DISABLE, STATUS, RESET }

# ===================================================================
# 2. CORE DATA MODELS (@model types)
# ===================================================================

type Entity @model @auth(rules: [{ allow: private }]) {
  id: ID!
  entityName: String! @index(name: "byEntityName")
  gameUrlDomain: String!
  gameUrlPath: String!
  entityLogo: AWSURL
  isActive: Boolean! @default(value: "true")
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  
  scraperStates: [ScraperState] @hasMany(indexName: "byEntityScraperState", fields: ["id"])
  scraperJobs: [ScraperJob] @hasMany(indexName: "byEntityScraperJob", fields: ["id"])
  scrapeURLs: [ScrapeURL] @hasMany(indexName: "byEntityScrapeURL", fields: ["id"])
  venues: [Venue] @hasMany(indexName: "byEntityVenue", fields: ["id"])
  games: [Game] @hasMany(indexName: "byEntityGame", fields: ["id"])
  assets: [Asset] @hasMany(indexName: "byEntityAsset", fields: ["id"])
}

type ScrapeStructure @model @auth(rules: [{ allow: private }]) {
  id: ID!
  fields: [String]!
  structureLabel: String!
  occurrenceCount: Int!
  firstSeenAt: AWSDateTime!
  lastSeenAt: AWSDateTime!
  exampleUrl: AWSURL
}

type DataSync @model @auth(rules: [{ allow: private }]) {
  id: ID!
  syncedAt: AWSDateTime!
  method: DataSource!
  sourceUrl: AWSURL
  title: String
  content: String
}

type ScraperState @model @auth(rules: [{ allow: private }]) {
  id: ID!
  isRunning: Boolean!
  lastScannedId: Int!
  lastRunStartTime: AWSDateTime
  lastRunEndTime: AWSDateTime
  consecutiveBlankCount: Int!
  totalScraped: Int!
  totalErrors: Int!
  enabled: Boolean!
  currentLog: [ScraperLogData]
  lastGamesProcessed: [ScrapedGameStatus]
  entityId: ID @index(name: "byEntityScraperState")
  entity: Entity @belongsTo(fields: ["entityId"])
}

type Venue @model @auth(rules: [{ allow: private }]) {
  id: ID!
  venueNumber: Int! @index(name: "byVenueNumber", sortKeyFields: ["name"])
  name: String!
  aliases: [String]
  address: String
  city: String
  country: String
  # ADD: Flag for special venues like "Unassigned"
  isSpecial: Boolean @default(value: "false")
  details: VenueDetails @hasOne
  assets: [Asset] @hasMany(indexName: "byVenue", fields: ["id"])
  games: [Game] @hasMany(indexName: "byVenue", fields: ["id"])
  series: [TournamentSeries] @hasMany(indexName: "byVenue", fields: ["id"])
  playerMemberships: [PlayerVenue] @hasMany(indexName: "byVenue", fields: ["id"])
  registeredPlayers: [Player] @hasMany(indexName: "byRegistrationVenue", fields: ["id"])
  entityId: ID @index(name: "byEntityVenue", sortKeyFields: ["name"])
  entity: Entity @belongsTo(fields: ["entityId"])
}

type VenueDetails @model @auth(rules: [{ allow: private }]) {
  id: ID!
  startDate: AWSDateTime!
  status: VenueStatus!
  lastCustomerSuccessVisit: AWSDateTime
  totalGamesHeld: Int
  averagePlayersPerGame: Float
  gameNights: [String]
  venueId: ID! @index(name: "byVenue")
  venue: Venue @belongsTo(fields: ["venueId"])
}

type TournamentSeriesTitle @model @auth(rules: [{ allow: private }]) {
  id: ID!
  title: String!
  aliases: [String]
  seriesInstances: [TournamentSeries] @hasMany(indexName: "byTournamentSeriesTitle", fields: ["id"])
}

type TournamentSeries @model @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  year: Int!
  status: SeriesStatus!
  startDate: AWSDateTime
  endDate: AWSDateTime
  events: [String]
  numberOfEvents: Int
  guaranteedPrizepool: Float
  estimatedPrizepool: Float
  actualPrizepool: Float
  tournamentSeriesTitleId: ID! @index(name: "byTournamentSeriesTitle", sortKeyFields: ["year"])
  title: TournamentSeriesTitle @belongsTo(fields: ["tournamentSeriesTitleId"])
  venueId: ID @index(name: "byVenue") # CHANGED: Made optional
  venue: Venue @belongsTo(fields: ["venueId"])
  games: [Game] @hasMany(indexName: "byTournamentSeries", fields: ["id"])
}

type Game @model @auth(rules: [{ allow: private }]) {
  # --- Core Identification ---
  id: ID!
  name: String!
  gameType: GameType!
  gameVariant: GameVariant!
  gameStatus: GameStatus! @index(name: "byStatus", queryField: "gamesByStatus", sortKeyFields: ["gameStartDateTime"])

  # --- Scheduling & Timestamps ---
  gameStartDateTime: AWSDateTime!
  gameEndDateTime: AWSDateTime
  registrationStatus: String
  totalDuration: String
  gameFrequency: GameFrequency

  # --- Financials & Buy-in ---
  buyIn: Float
  rake: Float
  startingStack: Int
  hasGuarantee: Boolean
  guaranteeAmount: Float

  # --- Aggregates & Results ---
  prizepool: Float
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int

  # --- Calculated Financial Metrics ---
  revenueByBuyIns: Float
  totalRake: Float
  profitLoss: Float
  guaranteeOverlay: Float
  guaranteeSurplus: Float

  # --- Live Game Data ---
  playersRemaining: Int
  totalChipsInPlay: Float
  averagePlayerStack: Float

  # --- Categorization & Metadata ---
  tournamentType: TournamentType

  isRegular: Boolean
  isSeries: Boolean
  isSatellite: Boolean
  seriesName: String
  gameTags: [String]

  # --- Data Source (SIMPLE REFERENCE ONLY - NO SCRAPER FIELDS) ---
  sourceUrl: AWSURL @index(name: "bySourceUrl", queryField: "gameBySourceUrl")
  tournamentId: Int
  dataSource: DataSource
  originalScrapedData: AWSJSON

  # --- NEW: Venue Assignment Tracking ---
  venueAssignmentStatus: VenueAssignmentStatus @default(value: "PENDING_ASSIGNMENT")
  requiresVenueAssignment: Boolean @default(value: "false")
  suggestedVenueName: String
  venueAssignmentConfidence: Float

  # --- Relationships ---
  venueId: ID @index(name: "byVenue", sortKeyFields: ["gameStartDateTime"]) ## <-- CHANGED: Made optional
  venue: Venue @belongsTo(fields: ["venueId"])
  tournamentSeriesId: ID @index(name: "byTournamentSeries", sortKeyFields: ["gameStartDateTime"])
  tournamentSeries: TournamentSeries @belongsTo(fields: ["tournamentSeriesId"])
  structure: TournamentStructure @hasOne
  playerEntries: [PlayerEntry] @hasMany(indexName: "byGame", fields: ["id"])
  playerResults: [PlayerResult] @hasMany(indexName: "byGame", fields: ["id"])
  entityId: ID @index(name: "byEntityGame", sortKeyFields: ["gameStartDateTime"])
  entity: Entity @belongsTo(fields: ["entityId"])

  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type TournamentStructure @model @auth(rules: [{ allow: private }]) {
  id: ID!
  levels: [TournamentLevel!]
  breaks: [Break!]
  gameId: ID! @index(name: "byGame")
  game: Game @belongsTo(fields: ["gameId"])
}

type TournamentLevelData @model @auth(rules: [{ allow: private }]) {
  id: ID!
  levels: [TournamentLevel!]
  gameId: ID! @index(name: "byGame")
}

type CashStructure @model @auth(rules: [{ allow: private }]) {
  id: ID!
  stakes: String!
  minBuyIn: Float
  maxBuyIn: Float
  gameId: ID! @index(name: "byGame")
}

type RakeStructure @model @auth(rules: [{ allow: private }]) {
  id: ID!
  rakePercentage: Float
  rakeCap: Float
  gameId: ID! @index(name: "byGame")
}

type Player @model @auth(rules: [{ allow: private }]) {
  id: ID!
  primaryEntityId: ID @index(name: "byPrimaryEntity")
  firstName: String!
  lastName: String!
  phone: String @index(name: "byPhone", queryField: "playerByPhone")
  email: String @index(name: "byEmail", queryField: "playerByEmail")
  status: PlayerAccountStatus!
  category: PlayerAccountCategory!
  targetingClassification: PlayerTargetingClassification!
  registrationDate: AWSDateTime!
  firstGamePlayed: AWSDateTime
  lastPlayedDate: AWSDateTime
  creditBalance: Int
  pointsBalance: Int

  # --- ADDED RELATIONSHIP FIELDS ---
  playerSummary: PlayerSummary @hasOne(fields: ["id"])
  knownIdentities: [KnownPlayerIdentity] @hasMany(indexName: "byPlayer", fields: ["id"])
  marketingPreferences: PlayerMarketingPreferences @hasOne(fields: ["id"])
  marketingMessages: [PlayerMarketingMessage] @hasMany(indexName: "byPlayer", fields: ["id"])
  # --- END ADDED FIELDS ---

  playerVenues: [PlayerVenue] @hasMany(indexName: "byVenue", fields: ["id"])
  playerEntries: [PlayerEntry] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerResults: [PlayerResult] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerTickets: [PlayerTicket] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerTransactions: [PlayerTransaction] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerCredits: [PlayerCredits] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerPoints: [PlayerPoints] @hasMany(indexName: "byPlayer", fields: ["id"])

  venueAssignmentStatus: VenueAssignmentStatus @default(value: "PENDING_ASSIGNMENT")
  registrationVenueId: ID @index(name: "byRegistrationVenue")
  registrationVenue: Venue @belongsTo(fields: ["registrationVenueId"])
  updatedAt: AWSDateTime!
}

type PlayerSummary @model @auth(rules: [{ allow: private }]) {
  id: ID!
  playerId: ID! @index(name: "byPlayer")
  gamesPlayedLast30Days: Int
  gamesPlayedLast90Days: Int
  gamesPlayedAllTime: Int
  averageFinishPosition: Float
  netBalance: Float
  player: Player @belongsTo(fields: ["playerId"])

  # --- FIELDS ADDED TO MATCH QUERIES ----
  sessionsPlayed: Int
  tournamentsPlayed: Int
  cashGamesPlayed: Int
  venuesVisited: Int
  tournamentWinnings: Float
  tournamentBuyIns: Float
  tournamentITM: Int
  tournamentsCashed: Int
  cashGameWinnings: Float
  cashGameBuyIns: Float
  totalWinnings: Float
  totalBuyIns: Float
  lastPlayed: AWSDateTime!
}

type PlayerEntry @model @auth(rules: [{ allow: private }]) {
  id: ID!
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["gameStartDateTime"])
  gameId: ID! @index(name: "byGame")
  venueId: ID @index(name: "byVenue") ## <-- CHANGED: Made optional
  status: PlayerEntryStatus!
  registrationTime: AWSDateTime!
  eliminationTime: AWSDateTime
  gameStartDateTime: AWSDateTime!
  lastKnownStackSize: Int
  tableNumber: Int
  seatNumber: Int
  numberOfReEntries: Int
  isMultiDayTournament: Boolean
  player: Player @belongsTo(fields: ["playerId"])
  game: Game @belongsTo(fields: ["gameId"])
}

type PlayerResult @model @auth(rules: [{ allow: private }]) {
  id: ID!
  finishingPlace: Int
  isMultiDayQualification: Boolean
  prizeWon: Boolean
  amountWon: Float
  totalRunners: Int
  pointsEarned: Float
  playerId: ID! @index(name: "byPlayer")
  player: Player @belongsTo(fields: ["playerId"])
  gameId: ID! @index(name: "byGame")
  game: Game @belongsTo(fields: ["gameId"])
}

type PlayerVenue @model @auth(rules: [{ allow: private }]) {
  id: ID!
  totalGamesPlayed: Int
  averageBuyIn: Float
  firstPlayedDate: AWSDateTime
  lastPlayedDate: AWSDateTime
  targetingClassification: PlayerVenueTargetingClassification!
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["venueId"])
  player: Player @belongsTo(fields: ["playerId"])
  venueId: ID! @index(name: "byVenue", sortKeyFields: ["playerId"])
  venue: Venue @belongsTo(fields: ["venueId"])
}

type PlayerTransaction @model @auth(rules: [{ allow: private }]) {
  id: ID!
  type: TransactionType!
  amount: Float!
  rake: Float
  paymentSource: PaymentSourceType!
  transactionDate: AWSDateTime!
  notes: String
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["transactionDate"])
  player: Player @belongsTo(fields: ["playerId"])
  gameId: ID @index(name: "byGame")
}

type PlayerCredits @model @auth(rules: [{ allow: private }]) {
  id: ID!
  type: CreditTransactionType!
  changeAmount: Float!
  balanceAfter: Float!
  transactionDate: AWSDateTime!
  reason: String
  expiryDate: AWSDateTime
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["transactionDate"])
  player: Player @belongsTo(fields: ["playerId"])
  relatedGameId: ID @index(name: "byGame")
  relatedTransactionId: ID
}

type PlayerPoints @model @auth(rules: [{ allow: private }]) {
  id: ID!
  type: PointsTransactionType!
  changeAmount: Float!
  balanceAfter: Float!
  transactionDate: AWSDateTime!
  reason: String
  expiryDate: AWSDateTime
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["transactionDate"])
  player: Player @belongsTo(fields: ["playerId"])
  relatedGameId: ID @index(name: "byGame")
  relatedTransactionId: ID
}

type KnownPlayerIdentity @model @auth(rules: [{ allow: private }]) {
  id: ID!
  sourceSystem: String!
  identityValue: String!
  identityType: String!
  playerId: ID! @index(name: "byPlayer")
  player: Player @belongsTo(fields: ["playerId"])
}

type TicketTemplate @model @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  description: String
  value: Float!
  validityDays: Int!
  originGameId: ID
  targetGameId: ID
  playerTickets: [PlayerTicket] @hasMany(indexName: "byTicketTemplate", fields: ["id"])
}

type PlayerTicket @model @auth(rules: [{ allow: private }]) {
  id: ID!
  assignedAt: AWSDateTime!
  expiryDate: AWSDateTime!
  status: TicketStatus!
  usedInGameId: ID
  playerId: ID! @index(name: "byPlayer")
  player: Player @belongsTo(fields: ["playerId"])
  ticketTemplateId: ID! @index(name: "byTicketTemplate")
  ticketTemplate: TicketTemplate @belongsTo(fields: ["ticketTemplateId"])
}

type MarketingMessage @model @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  subject: String
  emailBody: String
  smsBody: String
  sentMessages: [PlayerMarketingMessage] @hasMany(indexName: "byMarketingMessage", fields: ["id"])
}

type PlayerMarketingMessage @model @auth(rules: [{ allow: private }]) {
  id: ID!
  status: MessageStatus!
  sentAt: AWSDateTime!
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["sentAt"])
  marketingMessageId: ID! @index(name: "byMarketingMessage")
}

type PlayerMarketingPreferences @model @auth(rules: [{ allow: private }]) {
  id: ID!
  optOutSms: Boolean
  optOutEmail: Boolean
  playerId: ID! @index(name: "byPlayer")
  player: Player @belongsTo(fields: ["playerId"])
}

type User @model @auth(rules: [
  { allow: owner, ownerField: "id", operations: [read, update] },
  { allow: private, operations: [create, read] },
  { allow: groups, groups: ["SUPER_ADMIN"], operations: [create, read, update, delete] }
]) {
  id: ID!
  username: String!
  email: String!
  role: UserRole!
  preferences: [UserPreference] @hasMany(indexName: "byUser", fields: ["id"])
}

type UserPreference @model @auth(rules: [{ allow: owner, ownerField: "userId" }]) {
  id: ID!
  page: String!
  widget: String!
  preference: AWSJSON
  userId: ID! @index(name: "byUser")
}

type Staff @model @auth(rules: [{ allow: private }]) {
  id: ID!
  firstName: String!
  lastName: String
  role: StaffRole!
  assignedVenueId: ID @index(name: "byVenue")
}

type Asset @model @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  type: String!
  condition: AssetCondition!
  acquiredDate: AWSDateTime!
  lastCheckedDate: AWSDateTime!
  venueId: ID! @index(name: "byVenue")
  venue: Venue @belongsTo(fields: ["venueId"])
  entityId: ID @index(name: "byEntityAsset", sortKeyFields: ["type"])
  entity: Entity @belongsTo(fields: ["entityId"])
}

type SocialAccount @model @auth(rules: [{ allow: private }]) {
  id: ID!
  platform: String!
  accountName: String!
  apiKey: String
  apiSecret: String
}

type SocialPost @model @auth(rules: [{ allow: private }]) {
  id: ID!
  content: String!
  imageUrl: AWSURL
  postedAt: AWSDateTime!
  socialAccountId: ID! @index(name: "bySocialAccount", sortKeyFields: ["postedAt"])
}

type ScraperJob @model(queries: { list: null }) @auth(rules: [{ allow: private }]) {
  id: ID!
  jobId: String! @index(name: "byJobId")
  triggerSource: ScraperJobTriggerSource!
  triggeredBy: String
  startTime: AWSDateTime!
  endTime: AWSDateTime
  durationSeconds: Int
  maxGames: Int
  targetURLs: [String]
  isFullScan: Boolean
  startId: Int
  endId: Int
  status: ScraperJobStatus! @index(name: "byStatus", sortKeyFields: ["startTime"])
  totalURLsProcessed: Int
  newGamesScraped: Int
  gamesUpdated: Int
  gamesSkipped: Int
  errors: Int
  blanks: Int
  averageScrapingTime: Float
  successRate: Float
  errorMessages: [String]
  failedURLs: [String]
  urlResults: [ScraperJobURLResult]
  scrapeAttempts: [ScrapeAttempt] @hasMany(indexName: "byScraperJob", fields: ["id"])
  entityId: ID @index(name: "byEntityScraperJob", sortKeyFields: ["startTime"])
  entity: Entity @belongsTo(fields: ["entityId"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type ScrapeURL @model(queries: { get: "getScrapeURL", list: null }) @auth(rules: [{ allow: private }]) {  id: ID!
  url: AWSURL! @index(name: "byURL", queryField: "scrapeURLByURL")
  tournamentId: Int! @index(name: "byTournamentId")

  # === FIELDS MOVED FROM GAME TABLE ===
  doNotScrape: Boolean!
  sourceDataIssue: Boolean
  gameDataVerified: Boolean
  missingKeysFromScrape: [String]
  sourceSystem: String! @index(name: "bySourceSystem", queryField: "scrapeURLsBySourceSystem", sortKeyFields: ["tournamentId"])

  # === ORIGINAL SCRAPEURL FIELDS ===
  status: ScrapeURLStatus!
  placedIntoDatabase: Boolean!
  firstScrapedAt: AWSDateTime!
  lastScrapedAt: AWSDateTime!
  lastSuccessfulScrapeAt: AWSDateTime
  timesScraped: Int!
  timesSuccessful: Int!
  timesFailed: Int!
  consecutiveFailures: Int!
  lastScrapeStatus: ScrapeAttemptStatus
  lastScrapeMessage: String
  lastScrapeJobId: String
  gameId: ID @index(name: "byGameId")
  gameName: String
  gameStatus: GameStatus
  venueId: ID
  venueName: String
  lastDataHash: String
  hasDataChanges: Boolean
  lastFoundKeys: [String]
  lastStructureLabel: String
  averageScrapingTime: Float
  lastScrapingTime: Float
  attempts: [ScrapeAttempt] @hasMany(indexName: "byScrapeURL", fields: ["id"])
  entityId: ID @index(name: "byEntityScrapeURL")
  entity: Entity @belongsTo(fields: ["entityId"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!

    # === NEW CACHING FIELDS ===
  etag: String                          # ETag from last successful scrape
  lastModifiedHeader: String            # Last-Modified header from server
  contentHash: String                   # SHA-256 hash of HTML content (first 8 chars)
  s3StoragePrefix: String               # S3 folder path for this URL's HTML history
  latestS3Key: String                   # Most recent HTML file in S3
  s3StorageEnabled: Boolean @default(value: "true")
  
  # === ENHANCED TRACKING ===
  lastContentChangeAt: AWSDateTime      # When content actually changed
  totalContentChanges: Int @default(value: "0")
  lastHeaderCheckAt: AWSDateTime        # Last time we checked headers
  cachedContentUsedCount: Int @default(value: "0")  # Times we used cached content
  lastCacheHitAt: AWSDateTime          # When S3 cache was last used
  contentSize: Int                     # Size in bytes for monitoring
}

type ScrapeAttempt @model @auth(rules: [{ allow: private }]) {
  id: ID!
  url: AWSURL!
  tournamentId: Int!
  attemptTime: AWSDateTime!
  scraperJobId: ID! @index(name: "byScraperJob", sortKeyFields: ["attemptTime"])
  scraperJob: ScraperJob @belongsTo(fields: ["scraperJobId"])
  scrapeURLId: ID! @index(name: "byScrapeURL", sortKeyFields: ["attemptTime"])
  scrapeURL: ScrapeURL @belongsTo(fields: ["scrapeURLId"])
  status: ScrapeAttemptStatus!
  processingTime: Float
  gameName: String
  gameStatus: GameStatus
  registrationStatus: RegistrationStatus
  dataHash: String
  hasChanges: Boolean
  errorMessage: String
  errorType: String
  gameId: ID
  wasNewGame: Boolean
  fieldsUpdated: [String]
  foundKeys: [String]
  structureLabel: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type S3Storage @model @auth(rules: [{ allow: private }]) {
  id: ID!
  scrapeURLId: ID @index(name: "byScrapeURL", sortKeyFields: ["scrapedAt"])
  url: AWSURL! @index(name: "byURL", sortKeyFields: ["scrapedAt"])
  tournamentId: Int! @index(name: "byTournamentId", sortKeyFields: ["scrapedAt"])
  entityId: ID! @index(name: "byEntity", sortKeyFields: ["scrapedAt"])
  s3Key: String! @index(name: "byS3Key")
  s3Bucket: String!
  scrapedAt: AWSDateTime!
  contentSize: Int                    # Size in bytes
  contentHash: String                 # Full SHA-256 hash
  etag: String                        # ETag at time of scrape
  lastModified: String                # Last-Modified at time of scrape
  headers: AWSJSON                    # All response headers
  dataExtracted: Boolean @default(value: "false")
  gameId: ID @index(name: "byGameId")
  isManualUpload: Boolean @default(value: "false")
  uploadedBy: String                  # User who uploaded (for manual uploads)
  notes: String                       # Notes for manual uploads
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# ===================================================================
# 3. CUSTOM TYPES, INPUTS & RESPONSES (Non-model types)
# ===================================================================

type ScraperControlResponse {
  success: Boolean!
  message: String
  state: ScraperStateData
  results: ScraperResults
}

type ScraperStateData {
  id: String!
  isRunning: Boolean!
  lastScannedId: Int!
  lastRunStartTime: String
  lastRunEndTime: String
  consecutiveBlankCount: Int!
  totalScraped: Int!
  totalErrors: Int!
  enabled: Boolean!
  currentLog: [ScraperLogData]
  lastGamesProcessed: [ScrapedGameStatus]
  entityId: String
}

type ScraperResults {
  newGamesScraped: Int!
  gamesUpdated: Int!
  errors: Int!
  blanks: Int!
}

type ScraperLogData {
  timestamp: AWSDateTime!
  level: String!
  message: String!
  details: String
}

type ScrapedGameStatus {
  id: Int!
  name: String!
  status: String!
}

type TournamentLevel {
  levelNumber: Int!
  durationMinutes: Int
  smallBlind: Int
  bigBlind: Int
  ante: Int
}

type Break {
  levelNumberBeforeBreak: Int!
  durationMinutes: Int
}

input ClientMetricInput {
  metricName: String!
  value: Float!
  unit: String!
  dimensions: String
  timestamp: String
  metadata: String
}

type ClientMetricResponse {
  success: Boolean!
  message: String
  userId: String
}

type UserMetricsSummary {
  userId: String!
  userName: String
  totalActions: Int
  totalPageViews: Int
  totalErrors: Int
  lastActive: String
  mostUsedFeature: String
}

type S3StorageConnection {
  items: [S3Storage!]!
  nextToken: String
}

type CachingStatsResponse {
  totalURLs: Int!
  urlsWithETags: Int!
  urlsWithLastModified: Int!
  totalCacheHits: Int!
  totalCacheMisses: Int!
  averageCacheHitRate: Float!
  storageUsedMB: Float!
  recentCacheActivity: [CacheActivityLog!]
}

type CacheActivityLog {
  url: AWSURL!
  timestamp: AWSDateTime!
  action: String! # HIT, MISS, REFRESH, MANUAL
  reason: String
}

input ManualHTMLUploadInput {
  htmlContent: String!
  url: AWSURL!
  tournamentId: Int!
  entityId: ID!
  notes: String
  uploadedBy: String!
}

input ReScrapeFromCacheInput {
  s3Key: String!
  saveToDatabase: Boolean
}

type S3StorageHistoryResponse {
  items: [S3Storage]
  nextToken: String
}

type S3ContentResponse {
  s3Key: String!
  html: String!
  metadata: AWSJSON
  size: Int
  lastModified: AWSDateTime
}

type CachingStats {
  totalURLs: Int!
  urlsWithETags: Int!
  urlsWithLastModified: Int!
  totalCacheHits: Int!
  totalCacheMisses: Int!
  averageCacheHitRate: Float!
  storageUsedMB: Float!
  recentCacheActivity: [CacheActivity]
}

type CacheActivity {
  url: AWSURL!
  timestamp: AWSDateTime!
  action: String!  # HIT or MISS
  reason: String!
}

type S3StorageListResponse {
  items: [S3Storage]
  nextToken: String
}

type RefreshResponse {
  message: String!
  status: String!
}

type ReScrapeResult {
  name: String
  gameStartDateTime: AWSDateTime
  gameEndDateTime: AWSDateTime
  gameStatus: GameStatus
  registrationStatus: RegistrationStatus
  gameType: GameType
  gameVariant: GameVariant
  tournamentType: TournamentType
  prizepool: Float
  buyIn: Float
  rake: Float
  startingStack: Int
  hasGuarantee: Boolean
  guaranteeAmount: Float
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  totalDuration: String
  playersRemaining: Int
  seriesName: String
  gameTags: [String]
  venueMatch: VenueMatch
  existingGameId: ID
  doNotScrape: Boolean
  sourceUrl: AWSURL
  tournamentId: Int
  entityId: ID
  s3Key: String
  reScrapedAt: AWSDateTime
}

input UploadManualHTMLInput {
  htmlContent: String!
  url: AWSURL!
  tournamentId: Int!
  entityId: ID!
  notes: String
  uploadedBy: String
}

type EntityVenueAssignmentSummary {
  entityId: ID
  entityName: String!
  totalGames: Int
  gamesWithVenue: Int
  gamesNeedingVenue: Int
}

type EntityScraperMetrics {
  entityId: ID
  entityName: String!
  totalJobs: Int!
  successfulJobs: Int!
  failedJobs: Int!
  totalURLsScraped: Int!
}

type GamesNeedingVenueResponse {
  items: [Game]
  nextToken: String
  totalCount: Int
}

type VenueAssignmentSummary {
  totalGames: Int
  gamesWithVenue: Int
  gamesNeedingVenue: Int
  pendingAssignments: Int
  byEntity: [EntityVenueAssignmentSummary]
}

type VenueAssignmentResult {
  success: Boolean!
  gameId: ID!
  venueId: ID!
  affectedRecords: AffectedRecords
  error: String
}

type AffectedRecords {
  gameUpdated: Boolean
  playerEntriesUpdated: Int
  playerVenueRecordsCreated: Int
  playersWithRegistrationUpdated: Int
  playerSummariesUpdated: Int
}

type BatchVenueAssignmentResult {
  successful: [VenueAssignmentResult]
  failed: [VenueAssignmentResult]
  totalProcessed: Int
}

input VenueAssignment {
  gameId: ID!
  venueId: ID!
}

type ScraperJobURLResult {
  url: String!
  tournamentId: Int!
  status: ScrapeAttemptStatus!
  gameName: String
  processingTime: Float
  error: String
}

type ScraperMetrics {
  totalJobs: Int!
  successfulJobs: Int!
  failedJobs: Int!
  averageJobDuration: Float!
  totalURLsScraped: Int!
  successRate: Float!
  topErrors: [ErrorMetric!]
  hourlyActivity: [HourlyMetric!]
  byEntity: [EntityScraperMetrics]
}

type ErrorMetric {
  errorType: String!
  count: Int!
  urls: [String!]
}

type HourlyMetric {
  hour: String!
  jobCount: Int!
  urlsScraped: Int!
  successRate: Float!
}

type ScraperJobConnection {
  items: [ScraperJob!]
  nextToken: String
}

type ScrapeURLConnection {
  items: [ScrapeURL!]
  nextToken: String
}

input SaveTournamentInput {
  sourceUrl: AWSURL!
  venueId: ID
  existingGameId: ID
  doNotScrape: Boolean
  data: ScrapedGameDataInput!
  originalScrapedData: AWSJSON
  venueAssignmentStatus: VenueAssignmentStatus
  requiresVenueAssignment: Boolean
  suggestedVenueName: String
  venueAssignmentConfidence: Float
  entityId: ID
}

input ScrapedGameDataInput {
  name: String!
  gameStartDateTime: String
  gameEndDateTime: String
  gameStatus: GameStatus
  registrationStatus: RegistrationStatus
  gameVariant: GameVariant
  gameType: GameType
  prizepool: Float
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  totalDuration: String
  gameTags: [String]
  tournamentType: TournamentType
  buyIn: Float
  rake: Float
  startingStack: Int
  hasGuarantee: Boolean
  guaranteeAmount: Float
  levels: [ScrapedTournamentLevelInput!]
}

input ScrapedTournamentLevelInput {
  levelNumber: Int!
  durationMinutes: Int
  smallBlind: Int
  bigBlind: Int
  ante: Int
  breakMinutes: Int
}

input StartScraperJobInput {
  triggerSource: ScraperJobTriggerSource!
  maxGames: Int
  targetURLs: [String]
  startId: Int
  endId: Int
  isFullScan: Boolean
  triggeredBy: String
  entityId: ID
  isSequential: Boolean
}

type ScrapedGameSummary {
  id: String!
  name: String
  gameStatus: String
  registrationStatus: String
  gameStartDateTime: String
  inDatabase: Boolean
  doNotScrape: Boolean
  error: String
}

type ScrapedGameData {
  name: String!
  gameStartDateTime: String
  gameEndDateTime: String
  gameStatus: GameStatus
  registrationStatus: String
  gameType: GameType
  gameVariant: GameVariant
  tournamentType: TournamentType
  prizepool: Float
  revenueByBuyIns: Float
  profitLoss: Float
  buyIn: Float
  rake: Float
  totalRake: Float
  startingStack: Int
  hasGuarantee: Boolean
  guaranteeAmount: Float
  guaranteeOverlay: Float
  guaranteeSurplus: Float
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  totalDuration: String
  playersRemaining: Int
  totalChipsInPlay: Float
  averagePlayerStack: Float
  seriesName: String
  isRegular: Boolean
  isSeries: Boolean
  isSatellite: Boolean
  gameFrequency: GameFrequency
  gameTags: [String]
  levels: [ScrapedTournamentLevel!]
  breaks: [ScrapedBreak!]
  entries: [ScrapedPlayerEntry!]
  seating: [ScrapedPlayerSeating!]
  results: [ScrapedPlayerResult!]
  tables: [ScrapedTable!]
  rawHtml: String
  isNewStructure: Boolean
  structureLabel: String
  foundKeys: [String]
  venueMatch: ScrapedVenueMatch
  existingGameId: String
  doNotScrape: Boolean
  tournamentId: Int!
  entityId: ID
}

type ScrapedTournamentLevel {
  levelNumber: Int!
  durationMinutes: Int
  smallBlind: Int
  bigBlind: Int
  ante: Int
}

type ScrapedBreak {
  levelNumberBeforeBreak: Int!
  durationMinutes: Int
}

type ScrapedPlayerEntry {
  name: String!
}

type ScrapedPlayerSeating {
  name: String!
  table: Int
  seat: Int
  playerStack: Int
}

type ScrapedPlayerResult {
  rank: Int!
  name: String!
  winnings: Float
  points: Float
  isQualification: Boolean
}

type ScrapedTable {
  tableName: String!
  seats: [ScrapedTableSeatData!]
}

type ScrapedTableSeatData {
  seat: Int!
  isOccupied: Boolean!
  playerName: String
  playerStack: Int
}

type ScrapedVenueMatch {
  autoAssignedVenue: ScrapedVenueMatchDetails
  suggestions: [ScrapedVenueMatchDetails!]
}

type ScrapedVenueMatchDetails {
  id: ID!
  name: String!
  score: Float!
}

type AllCountsResult {
  playerCount: Int
  playerSummaryCount: Int
  playerEntryCount: Int
  playerResultCount: Int
  playerVenueCount: Int
  playerTransactionCount: Int
  playerCreditsCount: Int
  playerPointsCount: Int
  playerTicketCount: Int
  playerMarketingPreferencesCount: Int
  playerMarketingMessageCount: Int
  gameCount: Int
  tournamentStructureCount: Int
}

type VenueMatch {
  autoAssignedVenue: ScrapedVenueMatchDetails
  suggestions: [ScrapedVenueMatchDetails]
}

# ===================================================================
# 4. ROOT OPERATIONS (QUERY, MUTATION, SUBSCRIPTION)
# ===================================================================

type Query {
  fetchTournamentDataRange(startId: Int!, endId: Int!): [ScrapedGameSummary!] @function(name: "webScraperFunction-${env}")
  getScraperControlState(entityId: ID): ScraperControlResponse @function(name: "autoScraper-${env}")
  fetchUpdateCandidates: [String!] @function(name: "webScraperFunction-${env}")

  # NEW ENHANCED SCRAPER QUERIES
  getScraperJobsReport(status: ScraperJobStatus, limit: Int, nextToken: String): ScraperJobConnection @function(name: "scraperManagement-${env}")
  fetchScrapeURLDetails(url: AWSURL!): ScrapeURL @function(name: "scraperManagement-${env}")
  searchScrapeURLs(status: ScrapeURLStatus, limit: Int, nextToken: String): ScrapeURLConnection @function(name: "scraperManagement-${env}")
  getScraperMetrics(timeRange: TimeRange!, entityId: ID): ScraperMetrics @function(name: "scraperManagement-${env}")
  getUpdateCandidateURLs(limit: Int): [ScrapeURL!] @function(name: "scraperManagement-${env}")

  listEntitiesByDomain(domain: String!): [Entity] @function(name: "entityLookup-${env}")
  scrapeGame(url: AWSURL!, entityId: ID, venueId: ID, doNotScrape: Boolean): ScrapedGameData @function(name: "singleGameScraper-${env}")
  scrapeBulkGames(startId: Int!, endId: Int!, entityId: ID): [ScrapedGameSummary] @function(name: "bulkGamesScraper-${env}")
  listScraperJobs(entityId: ID, status: ScraperJobStatus, startTime: AWSDateTime, endTime: AWSDateTime, limit: Int, nextToken: String): ScraperJobConnection @function(name: "scraperJobQuery-${env}")
  listScrapeURLs(entityId: ID, status: ScrapeURLStatus, limit: Int, nextToken: String): ScrapeURLConnection @function(name: "scrapeURLQuery-${env}")

  # --- NEW VENUE ASSIGNMENT QUERIES ---
  listGamesNeedingVenue(limit: Int, nextToken: String, entityId: ID): GamesNeedingVenueResponse @function(name: "venueAssignmentService-${env}")  
  getVenueAssignmentSummary(entityId: ID): VenueAssignmentSummary @function(name: "venueAssignmentService-${env}")

  # NEW CLOUDWATCH MUTATIONS
  # Get current user's metrics summary
  getMyMetrics(timeRange: String): UserMetricsSummary
    @function(name: "getUserMetrics-${env}")
    @auth(rules: [
      { allow: private } # Users can only see their own metrics
    ])

  # Admin-only: Get any user's metrics
  getUserMetrics(userId: String!, timeRange: String): UserMetricsSummary
    @function(name: "getUserMetrics-${env}")
    @auth(rules: [
      { allow: groups, groups: ["Admin"] }
    ])

    playerCount: Int @function(name: "getModelCount-${env}")
    playerSummaryCount: Int @function(name: "getModelCount-${env}")
    playerEntryCount: Int @function(name: "getModelCount-${env}")
    playerResultCount: Int @function(name: "getModelCount-${env}")
    playerVenueCount: Int @function(name: "getModelCount-${env}")
    playerTransactionCount: Int @function(name: "getModelCount-${env}")
    playerCreditsCount: Int @function(name: "getModelCount-${env}")
    playerPointsCount: Int @function(name: "getModelCount-${env}")
    playerTicketCount: Int @function(name: "getModelCount-${env}")
    playerMarketingPreferencesCount: Int @function(name: "getModelCount-${env}")
    playerMarketingMessageCount: Int @function(name: "getModelCount-${env}")
    
    # Game-related counts
    gameCount: Int @function(name: "getModelCount-${env}")
    tournamentStructureCount: Int @function(name: "getModelCount-${env}")
    
    getAllCounts: AllCountsResult @function(name: "getModelCount-${env}")

    getS3StorageHistory(tournamentId: Int!, entityId: ID!, limit: Int): S3StorageConnection
        @function(name: "s3ManagementFunction-${env}")  # Use your actual function name
    
    viewS3Content(s3Key: String!): S3ContentResponse
        @function(name: "s3ManagementFunction-${env}")
    
    getCachingStats(entityId: ID!, timeRange: TimeRange): CachingStatsResponse
        @function(name: "s3ManagementFunction-${env}")
    
    listStoredHTML(url: AWSURL!, limit: Int): S3StorageConnection
        @function(name: "s3ManagementFunction-${env}")

}

type Mutation {
  fetchTournamentData(url: AWSURL!, forceRefresh: Boolean): ScrapedGameData @function(name: "webScraperFunction-${env}")
  saveTournamentData(input: SaveTournamentInput!): Game @function(name: "webScraperFunction-${env}")
  controlScraperOperation(operation: ScraperOperation!, entityId: ID): ScraperControlResponse @function(name: "autoScraper-${env}")
  triggerAutoScraping(maxGames: Int): ScraperControlResponse @function(name: "autoScraper-${env}")

  # NEW ENHANCED SCRAPER MUTATIONS
  startScraperJob(input: StartScraperJobInput!): ScraperJob @function(name: "scraperManagement-${env}")
  cancelScraperJob(jobId: String!): ScraperJob @function(name: "scraperManagement-${env}")
  modifyScrapeURLStatus(url: AWSURL!, status: ScrapeURLStatus, doNotScrape: Boolean): ScrapeURL @function(name: "scraperManagement-${env}")
  bulkModifyScrapeURLs(urls: [AWSURL!]!, status: ScrapeURLStatus, doNotScrape: Boolean): [ScrapeURL!] @function(name: "scraperManagement-${env}")

  # --- NEW VENUE ASSIGNMENT MUTATIONS ---
  assignVenueToGame(gameId: ID!, venueId: ID!): VenueAssignmentResult @function(name: "venueAssignmentService-${env}")
  batchAssignVenues(assignments: [VenueAssignment!]!): BatchVenueAssignmentResult @function(name: "venueAssignmentService-${env}")

  # NEW CLOUDWATCH MUTATIONS (FIXED - NO operations argument)
  publishClientMetrics(metrics: [ClientMetricInput!]!): ClientMetricResponse
    @function(name: "publishClientMetrics-${env}")
    @auth(rules: [
      { allow: private } # Only authenticated users
    ])

  # Upload manual HTML
  uploadManualHTML(input: ManualHTMLUploadInput!): S3Storage
  
  # Re-scrape from cached HTML
  reScrapeFromCache(input: ReScrapeFromCacheInput!): ScrapedGameData
  
  # Force refresh (bypass cache)
  forceRefreshScrape(url: AWSURL!): ScrapedGameData
  
  # Clear cache for a URL
  clearURLCache(url: AWSURL!): Boolean

}

type Subscription {
  onScraperJobUpdate(jobId: String): ScraperJob @aws_subscribe(mutations: ["startScraperJob", "cancelScraperJob"])
  onScrapeURLStatusChange(url: AWSURL): ScrapeURL @aws_subscribe(mutations: ["modifyScrapeURLStatus", "bulkModifyScrapeURLs"])
}

# ===================================================================
# END OF SCHEMA
# ===================================================================