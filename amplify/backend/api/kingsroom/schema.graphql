# ===================================================================
# KINGSROOM SCHEMA (MERGED WITH ENTITY-AWARE UPDATES)
# Version: 1.4.0
# ===================================================================
# 
# Changes in this version:
# - Added canonicalVenueId to Venue model
# - Added entityId, visityKey, canonicalVenueId to PlayerVenue model
# - Added entityId to PlayerEntry, PlayerResult, PlayerTransaction
# - Added BackgroundTask model
# - Added BackgroundTaskType, BackgroundTaskStatus enums
# - Added reassignment mutations and types
# ===================================================================

# ===================================================================
# 1. ENUMS
# ===================================================================

enum DataSource { SCRAPE, API, MANUAL }
enum AssetCondition { NEW, GOOD, FAIR, POOR, RETIRED }
enum VenueStatus { ACTIVE, INACTIVE, PENDING }
enum GameType { TOURNAMENT, CASH_GAME }
enum GameStatus { INITIATING, SCHEDULED, REGISTERING, RUNNING, CANCELLED, FINISHED, NOT_IN_USE, NOT_PUBLISHED, CLOCK_STOPPED, UNKNOWN }
enum GameVariant { NOT_PUBLISHED, NLHE, PLO, PLOM, PL04, PLOM4, PLOM5, PLO5, PLO6, PLOM6, PLMIXED, PLDC, NLDC }
enum GameFrequency { DAILY, WEEKLY, FORTNIGHTLY, MONTHLY, QUARTERLY, YEARLY, UNKNOWN }
enum RegistrationStatus { SCHEDULED, OPEN, FINAL, CLOSED, N_A }
enum TournamentType { FREEZEOUT, REBUY, SATELLITE, DEEPSTACK }
enum PaymentSourceType { CASH, SQUARE, CREDIT_CARD, INTERNAL_CREDIT, UNKNOWN }
enum PlayerAccountStatus { ACTIVE, SUSPENDED, PENDING_VERIFICATION }
enum PlayerAccountCategory { NEW, RECREATIONAL, REGULAR, VIP, LAPSED }
enum SeriesStatus { LIVE, SCHEDULED, COMPLETED }
enum PlayerTargetingClassification { NotPlayed, Active_EL, Active, Retain_Inactive31_60d, Retain_Inactive61_90d, Churned_91_120d, Churned_121_180d, Churned_181_360d, Churned_361d }
enum PlayerVenueTargetingClassification { Active_EL, Active, Retain_Inactive31_60d, Retain_Inactive61_90d, Churned_91_120d, Churned_121_180d, Churned_181_360d, Churned_361d }
enum TransactionType { BUY_IN, DEPOSIT, TICKET_AWARD, TICKET_REDEMPTION, CASH_AWARD, QUALIFICATION, WITHDRAWAL }
enum MessageStatus { SENT, DELIVERED, FAILED, READ }
enum UserRole { SUPER_ADMIN, ADMIN, VENUE_MANAGER, TOURNAMENT_DIRECTOR, MARKETING }
enum StaffRole { DEALER, FLOOR_MANAGER, SERVICE, TOURNAMENT_DIRECTOR }
enum TicketStatus { ACTIVE, EXPIRED, USED }
enum PlayerEntryStatus { REGISTERED, VOIDED, PLAYING, ELIMINATED, COMPLETED }
enum CreditTransactionType { AWARD_PROMOTION, AWARD_REFUND, AWARD_MANUAL, REDEEM_GAME_BUY_IN, EXPIRED }
enum PointsTransactionType { EARN_FROM_PLAY, EARN_FROM_PROMOTION, REDEEM_FOR_BUY_IN, REDEEM_FOR_MERCH, ADJUSTMENT_MANUAL, EXPIRED }
enum SeriesCategory { REGULAR, SPECIAL, PROMOTIONAL, CHAMPIONSHIP, SEASONAL }
enum HolidayType { NEW_YEAR, AUSTRALIA_DAY, EASTER, ANZAC_DAY, QUEENS_BIRTHDAY, CHRISTMAS, BOXING_DAY, MELBOURNE_CUP, LABOUR_DAY, OTHER }
enum VenueAssignmentStatus { AUTO_ASSIGNED, MANUALLY_ASSIGNED, PENDING_ASSIGNMENT, UNASSIGNED, RETROACTIVE_ASSIGNED }
enum SeriesAssignmentStatus { AUTO_ASSIGNED, MANUALLY_ASSIGNED, PENDING_ASSIGNMENT, UNASSIGNED, NOT_SERIES }
enum CostItemType {
  DEALER
  TOURNAMENT_DIRECTOR
  FLOOR_STAFF
  SECURITY
  PRIZE_CONTRIBUTION
  JACKPOT_CONTRIBUTION
  GUARANTEE_OVERLAY
  ADDED_VALUE
  BOUNTY
  VENUE_RENTAL
  EQUIPMENT_RENTAL
  FOOD_BEVERAGE
  MARKETING
  STREAMING
  INSURANCE
  LICENSING
  STAFF_TRAVEL
  PLAYER_ACCOMMODATION
  PROMOTION
  OTHER
}
enum CostItemRateType { STANDARD, OVERTIME, DOUBLE_TIME, PENALTY, HOLIDAY, SPECIAL, FLAT }
enum CostStatus { PENDING, PARTIAL, COMPLETE, ESTIMATED }
enum SnapshotType { AUTO, MANUAL, RECONCILED }
enum EntryType { INITIAL, REENTRY, DIRECT_BUYIN, QUALIFIED_CONTINUATION, AGGREGATE_LISTING }
enum ScraperJobTriggerSource { SCHEDULED, MANUAL, API, CONTROL, BULK, ADMIN }
enum ScraperJobStatus { QUEUED, RUNNING, COMPLETED, FAILED, CANCELLED, TIMEOUT }
enum ScrapeURLStatus { ACTIVE, INACTIVE, DO_NOT_SCRAPE, ERROR, ARCHIVED }
enum ScrapeAttemptStatus { SUCCESS, FAILED, SKIPPED_DONOTSCRAPE, SKIPPED_VENUE, BLANK, NO_CHANGES, UPDATED, SAVED, SUCCESS_EDITED, SAVED_EDITED, UPDATED_EDITED, NOT_FOUND, NOT_IN_USE, NOT_PUBLISHED }
enum TimeRange { LAST_HOUR, LAST_24_HOURS, LAST_7_DAYS, LAST_30_DAYS, CUSTOM }
enum ScraperOperation { START, STOP, ENABLE, DISABLE, STATUS, RESET }

# --- Social Pulse Enums ---
enum SocialPlatform { FACEBOOK, INSTAGRAM, TWITTER, LINKEDIN }
enum SocialAccountStatus { ACTIVE, INACTIVE, PENDING_VERIFICATION, ERROR, RATE_LIMITED }
enum SocialPostType { TEXT, IMAGE, VIDEO, LINK, EVENT, ALBUM, LIVE }
enum SocialScrapeStatus { RUNNING, SUCCESS, FAILED, SKIPPED, RATE_LIMITED, NO_NEW_CONTENT }
enum SocialPostStatus { ACTIVE, HIDDEN, ARCHIVED, DELETED }
enum ScheduledPostStatus { SCHEDULED, PUBLISHED, FAILED, CANCELLED }

# --- Background Task Enums (NEW) ---
enum BackgroundTaskType {
  VENUE_REASSIGNMENT
  BULK_VENUE_REASSIGNMENT
  ENTITY_REASSIGNMENT
  VENUE_CLONE
  BULK_IMPORT
  DATA_MIGRATION
  REPORT_GENERATION
  VENUE_DETAILS_RECALC
}

enum BackgroundTaskStatus {
  QUEUED
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

# ===================================================================
# 2. CORE DOMAIN (Entities, Venues, Series)
# ===================================================================

type Entity @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  entityName: String! @index(name: "byEntityName")
  gameUrlDomain: String!
  gameUrlPath: String!
  entityLogo: AWSURL
  isActive: Boolean! @default(value: "true")
  defaultVenueId: ID
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!

  # Relationships
  scraperStates: [ScraperState] @hasMany(indexName: "byEntityScraperState", fields: ["id"])
  scraperJobs: [ScraperJob] @hasMany(indexName: "byEntityScraperJob", fields: ["id"])
  scrapeURLs: [ScrapeURL] @hasMany(indexName: "byEntityScrapeURL", fields: ["id"])
  venues: [Venue] @hasMany(indexName: "byEntityVenue", fields: ["id"])
  games: [Game] @hasMany(indexName: "byEntityGame", fields: ["id"])
  assets: [Asset] @hasMany(indexName: "byEntityAsset", fields: ["id"])

  # Social Pulse Relationships
  socialAccounts: [SocialAccount] @hasMany(indexName: "bySocialAccountEntity", fields: ["id"])
}

type Venue @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  venueNumber: Int! @index(name: "byVenueNumber", sortKeyFields: ["name"])
  name: String!
  aliases: [String]
  address: String
  city: String
  country: String
  fee: Float
  isSpecial: Boolean @default(value: "false")
  details: VenueDetails @hasOne

  # NEW: Links venue "clones" across entities to the same physical location
  # If null, this IS the canonical (original) venue
  # If set, points to the canonical venue ID for cross-entity analytics
  canonicalVenueId: ID @index(name: "byCanonicalVenue")

  # Relationships
  assets: [Asset] @hasMany(indexName: "byVenue", fields: ["id"])
  games: [Game] @hasMany(indexName: "byVenue", fields: ["id"])
  series: [TournamentSeries] @hasMany(indexName: "byVenue", fields: ["id"])
  playerMemberships: [PlayerVenue] @hasMany(indexName: "byVenue", fields: ["id"])
  registeredPlayers: [Player] @hasMany(indexName: "byRegistrationVenue", fields: ["id"])

  # Social Pulse Relationships
  socialAccounts: [SocialAccount] @hasMany(indexName: "bySocialAccountVenue", fields: ["id"])

  entityId: ID @index(name: "byEntityVenue", sortKeyFields: ["name"])
  entity: Entity @belongsTo(fields: ["entityId"])
}

type VenueDetails @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  startDate: AWSDateTime!
  status: VenueStatus!
  lastCustomerSuccessVisit: AWSDateTime
  totalGamesHeld: Int
  averageUniquePlayersPerGame: Float
  averageEntriesPerGame: Float
  gameNights: [String]
  venueId: ID! @index(name: "byVenue")
  venue: Venue @belongsTo(fields: ["venueId"])
}

# --- VenueDetails Mutations ---
type VenueMetricsResult {
  success: Boolean!
  venuesProcessed: Int
  results: [VenueMetricsUpdateResult]
  error: String
}

type VenueMetricsUpdateResult {
  venueId: ID!
  detailsId: ID
  success: Boolean!
  error: String
}

type VenueMetricsPreview {
  success: Boolean!
  venueId: ID
  currentMetrics: VenueMetricsSnapshot
  calculatedMetrics: VenueMetricsSnapshot
  wouldChange: Boolean
  error: String
}

type VenueMetricsSnapshot {
  totalGamesHeld: Int
  averageUniquePlayersPerGame: Float
  averageEntriesPerGame: Float
  gameNights: [String]
  gamesIncluded: Int
  gamesExcluded: Int
  exclusionReasons: AWSJSON
  status: VenueStatus
}

input RecalculateVenueDetailsInput {
  venueId: ID
  entityId: ID
  forceAll: Boolean
}

input VenueMetricsPreviewInput {
  venueId: ID!
}

type TournamentSeriesTitle @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  title: String!
  aliases: [String]
  seriesCategory: SeriesCategory
  seriesInstances: [TournamentSeries] @hasMany(indexName: "byTournamentSeriesTitle", fields: ["id"])
}

type TournamentSeries @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String! @index(name: "byName", sortKeyFields: ["year"])
  year: Int! @index(name: "byYear", sortKeyFields: ["name"])
  quarter: Int @index(name: "byQuarter", sortKeyFields: ["year"])
  month: Int @index(name: "byMonth", sortKeyFields: ["year"])
  seriesCategory: SeriesCategory! @default(value: "REGULAR") @index(name: "bySeriesCategory", sortKeyFields: ["year"])
  holidayType: HolidayType @index(name: "byHolidayType", sortKeyFields: ["year"])
  status: SeriesStatus!
  startDate: AWSDateTime
  endDate: AWSDateTime
  numberOfEvents: Int
  guaranteedPrizepool: Float
  estimatedPrizepool: Float
  actualPrizepool: Float

  # Relationships
  tournamentSeriesTitleId: ID! @index(name: "byTournamentSeriesTitle", sortKeyFields: ["year"])
  title: TournamentSeriesTitle @belongsTo(fields: ["tournamentSeriesTitleId"])
  venueId: ID @index(name: "byVenue")
  venue: Venue @belongsTo(fields: ["venueId"])
  games: [Game] @hasMany(indexName: "byTournamentSeries", fields: ["id"])
}

# ===================================================================
# 3. GAME DOMAIN & CONSOLIDATION
# ===================================================================

type Game @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  # --- Core Identification ---
  id: ID!
  name: String!
  gameType: GameType!
  gameVariant: GameVariant!
  gameStatus: GameStatus! @index(name: "byStatus", queryField: "gamesByStatus", sortKeyFields: ["gameStartDateTime"])

  # --- Scheduling & Timestamps ---
  gameStartDateTime: AWSDateTime!
  gameEndDateTime: AWSDateTime
  registrationStatus: RegistrationStatus @index(name: "byRegistrationStatus", queryField: "gamesByRegistrationStatus", sortKeyFields: ["gameStartDateTime"])
  totalDuration: String
  gameFrequency: GameFrequency

  # --- Financials & Buy-in ---
  buyIn: Float
  rake: Float
  venueFee: Float
  startingStack: Int
  hasGuarantee: Boolean
  guaranteeAmount: Float

  # --- Aggregates & Results ---
  prizepoolPaid: Float
  prizepoolCalculated: Float
  totalUniquePlayers: Int
  totalRebuys: Int
  totalAddons: Int
  totalInitialEntries: Int
  totalEntries: Int

  # --- Calculated Financial Metrics (Simplified) ---
  totalBuyInsCollected: Float
  rakeRevenue: Float
  prizepoolPlayerContributions: Float
  prizepoolAddedValue: Float
  prizepoolSurplus: Float
  guaranteeOverlayCost: Float
  gameProfit: Float

  # --- Live Game Data ---
  playersRemaining: Int
  totalChipsInPlay: Float
  averagePlayerStack: Float

  # --- Categorization & Metadata ---
  tournamentType: TournamentType
  isRegular: Boolean
  isSatellite: Boolean
  gameTags: [String]
  dealerDealt: Boolean

  # --- Series Reference Fields ---
  isSeries: Boolean
  seriesName: String
  isMainEvent: Boolean
  eventNumber: Int
  dayNumber: Int
  flightLetter: String
  finalDay: Boolean

  # --- Multi-Day Consolidation Fields ---
  parentGameId: ID @index(name: "byParentGame", sortKeyFields: ["gameStartDateTime"])
  parentGame: Game @belongsTo(fields: ["parentGameId"])
  childGames: [Game] @hasMany(indexName: "byParentGame", fields: ["id"])

  consolidationType: String @default(value: "STANDARD") @index(name: "byConsolidationType", sortKeyFields: ["gameStartDateTime"])
  consolidationKey: String @index(name: "byConsolidationKey", queryField: "gamesByConsolidationKey")

  # --- Data Confidence ---
  isPartialData: Boolean @default(value: "false")
  missingFlightCount: Int
  expectedTotalEntries: Int

  # --- Query Optimisation Keys ---
  gameDayOfWeek: String @index(name: "byDayOfWeek", sortKeyFields: ["gameStartDateTime"])
  buyInBucket: String @index(name: "byBuyInBucket", sortKeyFields: ["gameStartDateTime"])
  venueScheduleKey: String @index(name: "byVenueSchedule", sortKeyFields: ["gameStartDateTime"])
  venueGameTypeKey: String @index(name: "byVenueGameType", sortKeyFields: ["gameStartDateTime"])
  entityQueryKey: String @index(name: "byEntityQuery", sortKeyFields: ["gameStartDateTime"])
  entityGameTypeKey: String @index(name: "byEntityGameType", sortKeyFields: ["gameStartDateTime"])

  # --- Data Source ---
  sourceUrl: AWSURL @index(name: "bySourceUrl", queryField: "gameBySourceUrl")
  tournamentId: Int
  originalScrapedData: AWSJSON

  # --- Edit Tracking ---
  wasEdited: Boolean @default(value: "false")
  lastEditedAt: AWSDateTime
  lastEditedBy: String
  editHistory: AWSJSON

  # --- Venue & Series Tracking ---
  venueAssignmentStatus: VenueAssignmentStatus @default(value: "PENDING_ASSIGNMENT")
  requiresVenueAssignment: Boolean @default(value: "false")
  suggestedVenueName: String
  venueAssignmentConfidence: Float

  seriesAssignmentStatus: SeriesAssignmentStatus @default(value: "NOT_SERIES")
  seriesAssignmentConfidence: Float
  suggestedSeriesName: String

  # --- Structure Data ---
  levels: AWSJSON

  # --- Relationships ---
  venueId: ID @index(name: "byVenue", sortKeyFields: ["gameStartDateTime"])
  venue: Venue @belongsTo(fields: ["venueId"])
  tournamentSeriesId: ID @index(name: "byTournamentSeries", sortKeyFields: ["gameStartDateTime"])
  tournamentSeries: TournamentSeries @belongsTo(fields: ["tournamentSeriesId"])
  structure: TournamentStructure @hasOne
  gameCost: GameCost @hasOne(fields: ["id"])
  gameFinancialSnapshots: [GameFinancialSnapshot] @hasMany(indexName: "byGameFinancialSnapshot", fields: ["id"])
  playerEntries: [PlayerEntry] @hasMany(indexName: "byGame", fields: ["id"])
  playerResults: [PlayerResult] @hasMany(indexName: "byGame", fields: ["id"])

  # Social Pulse Relationships
  linkedSocialPosts: [SocialPost] @hasMany(indexName: "bySocialPostGame", fields: ["id"])

  entityId: ID @index(name: "byEntityGame", sortKeyFields: ["gameStartDateTime"])
             @index(name: "byEntityAndTournamentId", sortKeyFields: ["tournamentId"], queryField: "gamesByEntityAndTournamentId")
  entity: Entity @belongsTo(fields: ["entityId"])

  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type TournamentStructure @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  levels: [TournamentLevel!]
  breaks: [Break!]
  gameId: ID! @index(name: "byGame")
  game: Game @belongsTo(fields: ["gameId"])
}

type TournamentLevelData @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  levels: [TournamentLevel!]
  gameId: ID! @index(name: "byGame")
}

type CashStructure @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  stakes: String!
  minBuyIn: Float
  maxBuyIn: Float
  gameId: ID! @index(name: "byGame")
}

type RakeStructure @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  rakePercentage: Float
  rakeCap: Float
  gameId: ID! @index(name: "byGame")
}

type GameFinancialSnapshot
  @model(subscriptions: null)
  @auth(rules: [{ allow: private }]) {
  id: ID!

  # === CORE RELATIONSHIPS ===
  gameId: ID! @index(name: "byGameFinancialSnapshot")
  game: Game @belongsTo(fields: ["gameId"])
  gameCostId: ID

  # === DENORMALIZED FILTERS ===
  entityId: ID @index(name: "byEntityGameFinancialSnapshot", sortKeyFields: ["gameStartDateTime"])
  venueId: ID @index(name: "byVenueGameFinancialSnapshot", sortKeyFields: ["gameStartDateTime"])
  gameStartDateTime: AWSDateTime @index(name: "byGameStartDateFinancialSnapshot", sortKeyFields: ["netProfit"])

  # === REVENUE SIDE (from Game model) ===
  totalBuyInsCollected: Float @default(value: "0")
  rakeRevenue: Float @default(value: "0")
  venueFee: Float @default(value: "0")
  totalRevenue: Float! @default(value: "0")
  
  # === PRIZEPOOL BREAKDOWN (from Game model) ===
  prizepoolPlayerContributions: Float @default(value: "0")
  prizepoolAddedValue: Float @default(value: "0")
  prizepoolTotal: Float @default(value: "0")
  prizepoolSurplus: Float @default(value: "0")

  # === COST SIDE (from GameCost model) ===
  totalDealerCost: Float @default(value: "0")
  totalTournamentDirectorCost: Float @default(value: "0")
  totalFloorStaffCost: Float @default(value: "0")
  totalSecurityCost: Float @default(value: "0")
  totalStaffCost: Float @default(value: "0")
  totalPrizeContribution: Float @default(value: "0")
  totalJackpotContribution: Float @default(value: "0")
  totalGuaranteeOverlayCost: Float @default(value: "0")
  totalAddedValueCost: Float @default(value: "0")
  totalBountyCost: Float @default(value: "0")
  totalDirectGameCost: Float @default(value: "0")
  totalVenueRentalCost: Float @default(value: "0")
  totalEquipmentRentalCost: Float @default(value: "0")
  totalFoodBeverageCost: Float @default(value: "0")
  totalMarketingCost: Float @default(value: "0")
  totalStreamingCost: Float @default(value: "0")
  totalOperationsCost: Float @default(value: "0")
  totalInsuranceCost: Float @default(value: "0")
  totalLicensingCost: Float @default(value: "0")
  totalComplianceCost: Float @default(value: "0")
  totalStaffTravelCost: Float @default(value: "0")
  totalPlayerAccommodationCost: Float @default(value: "0")
  totalPromotionCost: Float @default(value: "0")
  totalOtherCost: Float @default(value: "0")
  totalCost: Float! @default(value: "0")

  # === PROFIT & DERIVED METRICS ===
  gameProfit: Float @default(value: "0")
  netProfit: Float! @default(value: "0")
  profitMargin: Float
  revenuePerPlayer: Float
  costPerPlayer: Float
  profitPerPlayer: Float
  rakePerEntry: Float
  dealerCostPerHour: Float
  staffCostPerPlayer: Float
  promoSpendPerPlayer: Float
  guaranteeCoverageRate: Float
  guaranteeMet: Boolean
  
  # Denormalized Game Data for Reporting
  totalUniquePlayers: Int
  totalEntries: Int
  guaranteeAmount: Float
  gameDurationMinutes: Int
  gameType: GameType
  tournamentType: TournamentType

  # === METADATA ===
  notes: String
  snapshotType: SnapshotType @default(value: "AUTO")
  isReconciled: Boolean @default(value: "false")
  reconciledAt: AWSDateTime
  reconciledBy: String

  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type GameCost @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  gameId: ID! @index(name: "byGameCost")
  game: Game @belongsTo(fields: ["gameId"])

  # --- Staff Costs ---
  totalDealerCost: Float @default(value: "0")
  totalTournamentDirectorCost: Float @default(value: "0")
  totalFloorStaffCost: Float @default(value: "0")
  totalSecurityCost: Float @default(value: "0")
  
  # --- Direct Game Costs ---
  totalPrizeContribution: Float @default(value: "0")
  totalJackpotContribution: Float @default(value: "0")
  totalGuaranteeOverlayCost: Float @default(value: "0")
  totalAddedValueCost: Float @default(value: "0")
  totalBountyCost: Float @default(value: "0")
  
  # --- Venue & Equipment ---
  totalVenueRentalCost: Float @default(value: "0")
  totalEquipmentRentalCost: Float @default(value: "0")
  
  # --- Operations ---
  totalFoodBeverageCost: Float @default(value: "0")
  totalMarketingCost: Float @default(value: "0")
  totalStreamingCost: Float @default(value: "0")
  
  # --- Compliance ---
  totalInsuranceCost: Float @default(value: "0")
  totalLicensingCost: Float @default(value: "0")
  
  # --- Travel ---
  totalStaffTravelCost: Float @default(value: "0")
  totalPlayerAccommodationCost: Float @default(value: "0")
  
  # --- Promotions & Other ---
  totalPromotionCost: Float @default(value: "0")
  totalOtherCost: Float @default(value: "0")
  
  # --- Aggregates ---
  totalStaffCost: Float @default(value: "0")
  totalDirectGameCost: Float @default(value: "0")
  totalOperationsCost: Float @default(value: "0")
  totalComplianceCost: Float @default(value: "0")
  totalCost: Float! @default(value: "0")

  # --- Line Items ---
  lineItems: [GameCostLineItem] @hasMany(indexName: "byGameCost", fields: ["id"])

  # --- Denormalized for Queries ---
  entityId: ID @index(name: "byEntityCost", sortKeyFields: ["gameDate"])
  venueId: ID @index(name: "byVenueCost", sortKeyFields: ["gameDate"])
  gameDate: AWSDateTime @index(name: "byGameDateCost", sortKeyFields: ["totalCost"])

  # --- Metadata ---
  notes: String
  isEstimate: Boolean @default(value: "false")
  costStatus: CostStatus @default(value: "PENDING")

  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type GameCostLineItem @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  gameCostId: ID! @index(name: "byGameCost")
  gameCost: GameCost @belongsTo(fields: ["gameCostId"])

  costItemId: ID! @index(name: "byCostItem")
  costItem: GameCostItem @belongsTo(fields: ["costItemId"])
  costType: CostItemType! @index(name: "byCostTypeLine", sortKeyFields: ["gameDate"])
  rateType: CostItemRateType @default(value: "STANDARD")

  # --- Amount Calculation ---
  amount: Float!
  quantity: Float @default(value: "1")
  rate: Float
  hours: Float
  
  # --- Staff-Specific ---
  staffMemberId: ID
  staffMemberName: String
  
  # --- Description ---
  description: String
  notes: String

  # --- Denormalized for Queries ---
  gameId: ID @index(name: "byGameLineItem")
  entityId: ID @index(name: "byEntityLineItem", sortKeyFields: ["gameDate"])
  venueId: ID @index(name: "byVenueLineItem", sortKeyFields: ["gameDate"])
  gameDate: AWSDateTime

  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type GameCostItem @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  costType: CostItemType! @index(name: "byCostType", sortKeyFields: ["name"])
  rateType: CostItemRateType
  defaultRate: Float
  isPerHour: Boolean @default(value: "false")
  isActive: Boolean @default(value: "true")
  description: String
  lineItems: [GameCostLineItem] @hasMany(indexName: "byCostItem", fields: ["id"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# --- Game Consolidation Preview Types ---

type ConsolidationPreviewResult {
  willConsolidate: Boolean!
  reason: String!
  consolidation: ConsolidationDetails
  warnings: [String!]
  detectedPattern: DetectedMultiDayPattern
}

type ConsolidationDetails {
  consolidationKey: String!
  keyStrategy: String!
  parentExists: Boolean!
  parentGameId: ID
  parentName: String!
  siblingCount: Int!
  siblings: [ConsolidationSibling!]
  projectedTotals: ProjectedConsolidationTotals
}

type ConsolidationSibling {
  id: ID!
  name: String!
  dayNumber: Int
  flightLetter: String
  gameStatus: GameStatus
  gameStartDateTime: AWSDateTime
  totalUniquePlayers: Int
  totalInitialEntries: Int
  totalEntries: Int
  finalDay: Boolean
}

type ProjectedConsolidationTotals {
  totalUniquePlayers: Int
  totalInitialEntries: Int
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  prizepoolPaid: Float
  prizepoolCalculated: Float
  earliestStart: AWSDateTime
  latestEnd: AWSDateTime
  projectedStatus: GameStatus
  isPartialData: Boolean
  missingFlightCount: Int
}

type DetectedMultiDayPattern {
  isMultiDay: Boolean!
  detectionSource: String
  parsedDayNumber: Int
  parsedFlightLetter: String
  isFinalDay: Boolean
  derivedParentName: String!
}

# ===================================================================
# 4. PLAYER DOMAIN
# ===================================================================

type Player @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  primaryEntityId: ID @index(name: "byPrimaryEntity")
  firstName: String!
  lastName: String!
  phone: String @index(name: "byPhone", queryField: "playerByPhone")
  email: String @index(name: "byEmail", queryField: "playerByEmail")
  status: PlayerAccountStatus!
  category: PlayerAccountCategory!
  targetingClassification: PlayerTargetingClassification!
  registrationDate: AWSDateTime!
  firstGamePlayed: AWSDateTime
  lastPlayedDate: AWSDateTime
  creditBalance: Int
  pointsBalance: Int

  playerSummary: PlayerSummary @hasOne(fields: ["id"])
  knownIdentities: [KnownPlayerIdentity] @hasMany(indexName: "byPlayer", fields: ["id"])
  marketingPreferences: PlayerMarketingPreferences @hasOne(fields: ["id"])
  marketingMessages: [PlayerMarketingMessage] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerVenues: [PlayerVenue] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerEntries: [PlayerEntry] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerResults: [PlayerResult] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerTickets: [PlayerTicket] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerTransactions: [PlayerTransaction] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerCredits: [PlayerCredits] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerPoints: [PlayerPoints] @hasMany(indexName: "byPlayer", fields: ["id"])

  venueAssignmentStatus: VenueAssignmentStatus @default(value: "PENDING_ASSIGNMENT")
  registrationVenueId: ID @index(name: "byRegistrationVenue")
  registrationVenue: Venue @belongsTo(fields: ["registrationVenueId"])
  updatedAt: AWSDateTime!
}

type PlayerSummary @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  playerId: ID! @index(name: "byPlayer")
  gamesPlayedLast30Days: Int
  gamesPlayedLast90Days: Int
  gamesPlayedAllTime: Int
  averageFinishPosition: Float
  netBalance: Float
  player: Player @belongsTo(fields: ["playerId"])
  sessionsPlayed: Int
  tournamentsPlayed: Int
  cashGamesPlayed: Int
  venuesVisited: Int
  tournamentWinnings: Float
  tournamentBuyIns: Float
  tournamentITM: Int
  tournamentsCashed: Int
  cashGameWinnings: Float
  cashGameBuyIns: Float
  totalWinnings: Float
  totalBuyIns: Float
  lastPlayed: AWSDateTime!
}

type PlayerEntry @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["gameStartDateTime"])
  gameId: ID! @index(name: "byGame")
  venueId: ID @index(name: "byVenue")
  
  # NEW: Entity that ran the game (for entity-level analytics)
  entityId: ID @index(name: "byEntityEntry", sortKeyFields: ["gameStartDateTime"])
  
  status: PlayerEntryStatus!
  registrationTime: AWSDateTime!
  eliminationTime: AWSDateTime
  gameStartDateTime: AWSDateTime!
  lastKnownStackSize: Int
  tableNumber: Int
  seatNumber: Int
  numberOfReEntries: Int
  player: Player @belongsTo(fields: ["playerId"])
  game: Game @belongsTo(fields: ["gameId"])

  # Multi-day tournament tracking
  isMultiDayTournament: Boolean
  qualifyingGameId: ID  # The child game they qualified from
  entryType: EntryType @default(value: "INITIAL")
  recordType: String @default(value: "ORIGINAL") @index(name: "byRecordType", sortKeyFields: ["gameStartDateTime"])
}

type PlayerResult @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  finishingPlace: Int
  isMultiDayQualification: Boolean
  prizeWon: Boolean
  amountWon: Float
  totalRunners: Int
  pointsEarned: Float
  gameStartDateTime: AWSDateTime!
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["gameStartDateTime"])
  player: Player @belongsTo(fields: ["playerId"])
  gameId: ID! @index(name: "byGame")
  game: Game @belongsTo(fields: ["gameId"])
  recordType: String @default(value: "ORIGINAL") @index(name: "byRecordTypeResult", sortKeyFields: ["gameStartDateTime"])
  venueId: ID @index(name: "byVenueResult", sortKeyFields: ["gameStartDateTime"])
  
  # NEW: Entity that ran the game (for entity-level analytics)
  entityId: ID @index(name: "byEntityResult", sortKeyFields: ["gameStartDateTime"])

  # Consolidation tracking
  isConsolidatedRecord: Boolean
  sourceEntryCount: Int        # How many flights this represents
  sourceBuyInCount: Int        # How many buy-ins this represents
  totalBuyInsPaid: Float       # Actual amount player paid
  netProfitLoss: Float         # amountWon - totalBuyInsPaid
  consolidatedIntoGameId: ID   # Points to parent game (for child results)
}

type PlayerVenue @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  
  # Core relationships
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["visityKey"])
  player: Player @belongsTo(fields: ["playerId"])
  
  venueId: ID! @index(name: "byVenue", sortKeyFields: ["playerId"])
  venue: Venue @belongsTo(fields: ["venueId"])
  
  # NEW: Entity that ran the games (enables entity+venue analytics)
  entityId: ID! @index(name: "byEntityPlayerVenue", sortKeyFields: ["venueId"])
  
  # NEW: Composite key for unique constraint and fast lookups
  # Format: "{playerId}#{entityId}#{venueId}"
  visityKey: String @index(name: "byVisitKey", queryField: "playerVenueByVisitKey")
  
  # NEW: Link to canonical venue for cross-entity aggregation
  canonicalVenueId: ID @index(name: "byCanonicalVenuePlayer", sortKeyFields: ["playerId"])
  
  # Stats for this player at this venue FOR THIS ENTITY
  totalGamesPlayed: Int
  averageBuyIn: Float
  totalBuyIns: Float
  totalWinnings: Float
  netProfit: Float
  firstPlayedDate: AWSDateTime
  lastPlayedDate: AWSDateTime
  
  # Targeting
  targetingClassification: PlayerVenueTargetingClassification!
}

type PlayerTransaction @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  type: TransactionType!
  amount: Float!
  rake: Float
  paymentSource: PaymentSourceType!
  transactionDate: AWSDateTime!
  notes: String
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["transactionDate"])
  player: Player @belongsTo(fields: ["playerId"])
  gameId: ID @index(name: "byGame")
  venueId: ID @index(name: "byVenueTransaction", sortKeyFields: ["transactionDate"])
  
  # NEW: Entity that ran the game/transaction (for entity-level analytics)
  entityId: ID @index(name: "byEntityTransaction", sortKeyFields: ["transactionDate"])
}

type PlayerCredits @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  type: CreditTransactionType!
  changeAmount: Float!
  balanceAfter: Float!
  transactionDate: AWSDateTime!
  reason: String
  expiryDate: AWSDateTime
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["transactionDate"])
  player: Player @belongsTo(fields: ["playerId"])
  relatedGameId: ID @index(name: "byGame")
  relatedTransactionId: ID
}

type PlayerPoints @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  type: PointsTransactionType!
  changeAmount: Float!
  balanceAfter: Float!
  transactionDate: AWSDateTime!
  reason: String
  expiryDate: AWSDateTime
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["transactionDate"])
  player: Player @belongsTo(fields: ["playerId"])
  relatedGameId: ID @index(name: "byGame")
  relatedTransactionId: ID
}

type KnownPlayerIdentity @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  sourceSystem: String!
  identityValue: String!
  identityType: String!
  playerId: ID! @index(name: "byPlayer")
  player: Player @belongsTo(fields: ["playerId"])
}

# ===================================================================
# 5. SCRAPER & INGESTION ENGINE
# ===================================================================

type ScraperJob @model(queries: { list: null }) @auth(rules: [{ allow: private }]) {
  id: ID!
  jobId: String! @index(name: "byJobId")
  triggerSource: ScraperJobTriggerSource!
  triggeredBy: String
  startTime: AWSDateTime!
  endTime: AWSDateTime
  durationSeconds: Int
  maxGames: Int
  targetURLs: [String]
  isFullScan: Boolean
  startId: Int
  endId: Int
  status: ScraperJobStatus! @index(name: "byStatus", sortKeyFields: ["startTime"])
  totalURLsProcessed: Int
  newGamesScraped: Int
  gamesUpdated: Int
  gamesSkipped: Int
  errors: Int
  blanks: Int
  averageScrapingTime: Float
  successRate: Float
  errorMessages: [String]
  failedURLs: [String]
  urlResults: [ScraperJobURLResult]
  scrapeAttempts: [ScrapeAttempt] @hasMany(indexName: "byScraperJob", fields: ["id"])
  entityId: ID @index(name: "byEntityScraperJob", sortKeyFields: ["startTime"])
  entity: Entity @belongsTo(fields: ["entityId"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type ScrapeURL @model(queries: { get: "getScrapeURL", list: null }) @auth(rules: [{ allow: private }]) {
  id: ID!
  url: AWSURL! @index(name: "byURL", queryField: "scrapeURLByURL")
  tournamentId: Int! @index(name: "byTournamentId")
  doNotScrape: Boolean!
  sourceDataIssue: Boolean
  gameDataVerified: Boolean
  missingKeysFromScrape: [String]
  sourceSystem: String @index(name: "bySourceSystem", queryField: "scrapeURLsBySourceSystem", sortKeyFields: ["tournamentId"])
  status: ScrapeURLStatus!
  placedIntoDatabase: Boolean!
  firstScrapedAt: AWSDateTime!
  lastScrapedAt: AWSDateTime!
  lastSuccessfulScrapeAt: AWSDateTime
  timesScraped: Int!
  timesSuccessful: Int!
  timesFailed: Int!
  consecutiveFailures: Int @default(value: "0")
  lastScrapeStatus: ScrapeAttemptStatus
  lastScrapeMessage: String
  lastScrapeJobId: String
  gameId: ID @index(name: "byGameId")
  gameName: String
  gameStatus: GameStatus
  venueId: ID
  venueName: String
  lastDataHash: String
  hasDataChanges: Boolean
  lastFoundKeys: [String]
  lastStructureLabel: String
  averageScrapingTime: Float
  lastScrapingTime: Float
  attempts: [ScrapeAttempt] @hasMany(indexName: "byScrapeURL", fields: ["id"])
  entityId: ID @index(name: "byEntityScrapeURL")
  entity: Entity @belongsTo(fields: ["entityId"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!

  etag: String
  lastModifiedHeader: String
  contentHash: String
  s3StoragePrefix: String
  latestS3Key: String
  s3StorageEnabled: Boolean @default(value: "true")
  lastContentChangeAt: AWSDateTime
  totalContentChanges: Int @default(value: "0")
  lastHeaderCheckAt: AWSDateTime
  cachedContentUsedCount: Int @default(value: "0")
  lastCacheHitAt: AWSDateTime
  contentSize: Int
  wasEdited: Boolean @default(value: "false")
}

type ScrapeAttempt @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  url: AWSURL!
  tournamentId: Int!
  attemptTime: AWSDateTime!
  scraperJobId: ID! @index(name: "byScraperJob", sortKeyFields: ["attemptTime"])
  scraperJob: ScraperJob @belongsTo(fields: ["scraperJobId"])
  scrapeURLId: ID! @index(name: "byScrapeURL", sortKeyFields: ["attemptTime"])
  scrapeURL: ScrapeURL @belongsTo(fields: ["scrapeURLId"])
  status: ScrapeAttemptStatus!
  processingTime: Float
  gameName: String
  gameStatus: GameStatus
  registrationStatus: RegistrationStatus
  dataHash: String
  hasChanges: Boolean
  errorMessage: String
  errorType: String
  gameId: ID
  wasNewGame: Boolean
  fieldsUpdated: [String]
  foundKeys: [String]
  structureLabel: String
  wasEdited: Boolean @default(value: "false")
  scrapedAt: AWSDateTime
  fieldsExtracted: [String]
  entityId: ID
  contentHash: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type ScraperState @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  isRunning: Boolean!
  lastScannedId: Int!
  lastRunStartTime: AWSDateTime
  lastRunEndTime: AWSDateTime
  consecutiveBlankCount: Int!
  totalScraped: Int!
  totalErrors: Int!
  enabled: Boolean!
  currentLog: [ScraperLogData]
  highestStoredId: Int
  lowestStoredId: Int
  knownGapRanges: AWSJSON
  lastGapScanAt: AWSDateTime
  totalGamesInDatabase: Int
  lastGamesProcessed: [ScrapedGameStatus]
  entityId: ID @index(name: "byEntityScraperState")
  entity: Entity @belongsTo(fields: ["entityId"])
}

type ScrapeStructure @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  fields: [String]!
  structureLabel: String!
  occurrenceCount: Int!
  firstSeenAt: AWSDateTime!
  lastSeenAt: AWSDateTime!
  exampleUrl: AWSURL
}

type DataSync @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  syncedAt: AWSDateTime!
  method: DataSource!
  sourceUrl: AWSURL
  title: String
  content: String
}

type S3Storage @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  scrapeURLId: ID @index(name: "byScrapeURL", sortKeyFields: ["scrapedAt"])
  url: AWSURL! @index(name: "byURL", sortKeyFields: ["scrapedAt"])
  tournamentId: Int! @index(name: "byTournamentId", sortKeyFields: ["scrapedAt"])
  entityId: ID! @index(name: "byEntity", sortKeyFields: ["scrapedAt"])
  s3Key: String! @index(name: "byS3Key")
  s3Bucket: String!
  scrapedAt: AWSDateTime!
  contentSize: Int
  contentHash: String
  etag: String
  lastModified: String
  headers: AWSJSON
  dataExtracted: Boolean @default(value: "false")
  gameId: ID @index(name: "byGameId")
  isManualUpload: Boolean @default(value: "false")
  uploadedBy: String
  notes: String
  previousVersions: [S3VersionHistory]
  gameStatus: String @index(name: "byS3GameStatus", queryField: "s3StorageByGameStatus", sortKeyFields: ["scrapedAt"])
  registrationStatus: String @index(name: "byS3RegistrationStatus", queryField: "s3StorageByRegistrationStatus", sortKeyFields: ["scrapedAt"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!

  isParsed: Boolean @default(value: "false")
  parsedDataHash: String
  extractedFields: [String]
  lastParsedAt: AWSDateTime
  parseCount: Int @default(value: "0")
  rescrapeCount: Int @default(value: "0")
  lastRescrapeAt: AWSDateTime
  dataChangedAt: AWSDateTime
  dataChangeCount: Int @default(value: "0")
}

# ===================================================================
# 6. SYSTEM, ADMIN & ASSETS
# ===================================================================

type User @model(subscriptions: null) @auth(rules: [
  { allow: private, operations: [create, read, update] },
  { allow: groups, groups: ["SUPER_ADMIN"], operations: [create, read, update, delete] }
]) {
  id: ID!
  username: String!
  email: String! @index(name: "byEmail", queryField: "userByEmail")
  role: UserRole!
  isActive: Boolean @default(value: "true")
  allowedPages: [String]
  firstName: String
  lastName: String
  phone: String
  avatar: AWSURL
  allowedEntityIds: [ID]
  allowedVenueIds: [ID]
  defaultEntityId: ID
  lastLoginAt: AWSDateTime
  lastActiveAt: AWSDateTime
  passwordLastChangedAt: AWSDateTime
  mustChangePassword: Boolean @default(value: "false")
  loginAttempts: Int @default(value: "0")
  lockedUntil: AWSDateTime
  createdBy: String
  updatedBy: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  preferences: [UserPreference] @hasMany(indexName: "byUser", fields: ["id"])
  auditLogs: [UserAuditLog] @hasMany(indexName: "byUser", fields: ["id"])
}

type UserPreference @model(subscriptions: null) @auth(rules: [{ allow: owner, ownerField: "userId" }]) {
  id: ID!
  page: String!
  widget: String!
  preference: AWSJSON
  userId: ID! @index(name: "byUser")
}

type UserAuditLog @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  userId: ID! @index(name: "byUser", sortKeyFields: ["createdAt"])
  user: User @belongsTo(fields: ["userId"])
  action: String!
  resource: String
  details: AWSJSON
  ipAddress: String
  userAgent: String
  createdAt: AWSDateTime!
}

type Staff @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  firstName: String!
  lastName: String
  role: StaffRole!
  assignedVenueId: ID @index(name: "byVenue")
}

type Asset @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  type: String!
  condition: AssetCondition!
  acquiredDate: AWSDateTime!
  lastCheckedDate: AWSDateTime!
  venueId: ID! @index(name: "byVenue")
  venue: Venue @belongsTo(fields: ["venueId"])
  entityId: ID @index(name: "byEntityAsset", sortKeyFields: ["type"])
  entity: Entity @belongsTo(fields: ["entityId"])
}

type TicketTemplate @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  description: String
  value: Float!
  validityDays: Int!
  originGameId: ID
  targetGameId: ID
  playerTickets: [PlayerTicket] @hasMany(indexName: "byTicketTemplate", fields: ["id"])
}

type PlayerTicket @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  assignedAt: AWSDateTime!
  expiryDate: AWSDateTime!
  status: TicketStatus!
  usedInGameId: ID
  playerId: ID! @index(name: "byPlayer")
  player: Player @belongsTo(fields: ["playerId"])
  ticketTemplateId: ID! @index(name: "byTicketTemplate")
  ticketTemplate: TicketTemplate @belongsTo(fields: ["ticketTemplateId"])
}

type MarketingMessage @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  subject: String
  emailBody: String
  smsBody: String
  sentMessages: [PlayerMarketingMessage] @hasMany(indexName: "byMarketingMessage", fields: ["id"])
}

type PlayerMarketingMessage @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  status: MessageStatus!
  sentAt: AWSDateTime!
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["sentAt"])
  marketingMessageId: ID! @index(name: "byMarketingMessage")
}

type PlayerMarketingPreferences @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  optOutSms: Boolean
  optOutEmail: Boolean
  playerId: ID! @index(name: "byPlayer")
  player: Player @belongsTo(fields: ["playerId"])
}

# ===================================================================
# 6.5 BACKGROUND TASK (NEW)
# ===================================================================

type BackgroundTask @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  
  # Who owns this task
  entityId: ID! @index(name: "byEntityTask", sortKeyFields: ["createdAt"], queryField: "tasksByEntity")
  
  # Task classification
  taskType: BackgroundTaskType!
  status: BackgroundTaskStatus!
  
  # What this task operates on
  targetType: String!
  targetId: ID
  targetIds: [ID]
  targetCount: Int
  
  # Task-specific data
  payload: AWSJSON
  
  # Progress tracking
  processedCount: Int
  progressPercent: Float
  
  # Results
  result: AWSJSON
  errorMessage: String
  
  # Timestamps
  createdAt: AWSDateTime!
  startedAt: AWSDateTime
  completedAt: AWSDateTime
  
  # User who initiated
  initiatedBy: String
}

# ===================================================================
# 6.6 SOCIAL PULSE
# ===================================================================

type SocialAccount @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  platform: SocialPlatform!
  platformAccountId: String! @index(name: "byPlatformAccountId", queryField: "socialAccountByPlatformId")
  accountName: String! @index(name: "byAccountName")
  accountHandle: String
  accountUrl: AWSURL!
  businessLocation: String @index(name: "byAccountLocation", queryField: "socialAccountsByLocation")
  tags: [String]
  profileImageUrl: AWSURL
  coverImageUrl: AWSURL
  bio: String
  followerCount: Int
  followingCount: Int
  postCount: Int
  hasFullHistory: Boolean @default(value: "false")
  pageDescription: String
  category: String
  website: String
  status: SocialAccountStatus! @default(value: "PENDING_VERIFICATION")
  isScrapingEnabled: Boolean! @default(value: "true")
  scrapeFrequencyMinutes: Int @default(value: "60")
  lastScrapedAt: AWSDateTime
  lastSuccessfulScrapeAt: AWSDateTime
  nextScheduledScrapeAt: AWSDateTime
  consecutiveFailures: Int @default(value: "0")
  lastErrorMessage: String
  hasPostAccess: Boolean @default(value: "false")
  accessTokenExpiry: AWSDateTime
  permissionsGranted: [String]
  entityId: ID @index(name: "bySocialAccountEntity")
  entity: Entity @belongsTo(fields: ["entityId"])
  venueId: ID @index(name: "bySocialAccountVenue")
  venue: Venue @belongsTo(fields: ["venueId"])
  posts: [SocialPost] @hasMany(indexName: "bySocialAccount", fields: ["id"])
  scrapeAttempts: [SocialScrapeAttempt] @hasMany(indexName: "bySocialAccountAttempt", fields: ["id"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  createdBy: String
}

type SocialPost @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  platformPostId: String! @index(name: "byPlatformPostId", queryField: "socialPostByPlatformId")
  postUrl: AWSURL
  postType: SocialPostType!
  accountName: String
  accountProfileImageUrl: String
  platform: String
  businessLocation: String @index(name: "byPostLocation", queryField: "socialPostsByLocation", sortKeyFields: ["postedAt"])
  content: String
  contentPreview: String
  rawContent: AWSJSON
  mediaUrls: [AWSURL]
  thumbnailUrl: AWSURL
  mediaType: String
  videoUrl: String
  videoThumbnailUrl: String
  videoWidth: Int
  videoHeight: Int
  videoTitle: String
  videoDescription: String
  likeCount: Int @default(value: "0")
  commentCount: Int @default(value: "0")
  shareCount: Int @default(value: "0")
  reactionCount: Int @default(value: "0")
  viewCount: Int
  postedAt: AWSDateTime! @index(name: "byPostedAt", sortKeyFields: ["likeCount"])
  scrapedAt: AWSDateTime!
  lastUpdatedAt: AWSDateTime
  status: SocialPostStatus! @default(value: "ACTIVE") @index(name: "byPostStatus", queryField: "socialPostsByPostStatus", sortKeyFields: ["postedAt"])
  isPromotional: Boolean @default(value: "false")
  isPinned: Boolean @default(value: "false")
  isTournamentRelated: Boolean @default(value: "false")
  tags: [String]
  sentiment: String
  contentCategory: String
  linkedGameId: ID @index(name: "bySocialPostGame")
  linkedGame: Game @belongsTo(fields: ["linkedGameId"])
  socialAccountId: ID! @index(name: "bySocialAccount", sortKeyFields: ["postedAt"])
  socialAccount: SocialAccount @belongsTo(fields: ["socialAccountId"])
  entityId: ID @index(name: "bySocialPostEntity", sortKeyFields: ["postedAt"])
  venueId: ID @index(name: "bySocialPostVenue", sortKeyFields: ["postedAt"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type SocialScrapeAttempt @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  status: SocialScrapeStatus!
  startedAt: AWSDateTime!
  completedAt: AWSDateTime
  durationMs: Int
  syncType: String
  postsFound: Int @default(value: "0")
  newPostsAdded: Int @default(value: "0")
  postsUpdated: Int @default(value: "0")
  errorMessage: String
  errorCode: String
  triggerSource: ScraperJobTriggerSource
  triggeredBy: String
  socialAccountId: ID! @index(name: "bySocialAccountAttempt", sortKeyFields: ["startedAt"])
  socialAccount: SocialAccount @belongsTo(fields: ["socialAccountId"])
  createdAt: AWSDateTime!
}

type SocialScheduledPost @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  content: String!
  mediaUrls: [AWSURL]
  linkUrl: AWSURL
  scheduledFor: AWSDateTime! @index(name: "byScheduledTime")
  publishedAt: AWSDateTime
  status: ScheduledPostStatus! @default(value: "SCHEDULED") @index(name: "byScheduledPostStatus", sortKeyFields: ["scheduledFor"])
  targetAccountIds: [ID!]!
  linkedGameId: ID @index(name: "byScheduledPostGame")
  templateType: String
  entityId: ID! @index(name: "byScheduledPostEntity", sortKeyFields: ["scheduledFor"])
  createdBy: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# ===================================================================
# 7. NON-MODEL TYPES & RESPONSES
# ===================================================================

# --- User Management Responses ---
type UserManagementResponse {
  success: Boolean!
  message: String
  user: User
  temporaryPassword: String
}

type ResetPasswordResponse {
  success: Boolean!
  message: String
  temporaryPassword: String
}

type UsersConnection {
  items: [User!]!
  nextToken: String
  totalCount: Int
}

# --- Scraper Types ---
type ScraperControlResponse {
  success: Boolean!
  message: String
  state: ScraperStateData
  results: ScraperResults
}

type ScraperStateData {
  id: String!
  isRunning: Boolean!
  lastScannedId: Int!
  lastRunStartTime: String
  lastRunEndTime: String
  consecutiveBlankCount: Int!
  totalScraped: Int!
  totalErrors: Int!
  enabled: Boolean!
  currentLog: [ScraperLogData]
  lastGamesProcessed: [ScrapedGameStatus]
  entityId: String
}

type ScraperResults {
  newGamesScraped: Int!
  gamesUpdated: Int!
  errors: Int!
  blanks: Int!
}

type ScraperLogData {
  timestamp: AWSDateTime!
  level: String!
  message: String!
  details: String
}

type ScrapedGameStatus {
  id: Int!
  name: String!
  status: String!
}

type ScraperJobURLResult {
  url: String!
  tournamentId: Int!
  status: ScrapeAttemptStatus!
  gameName: String
  processingTime: Float
  error: String
}

type ScraperMetrics {
  totalJobs: Int!
  successfulJobs: Int!
  failedJobs: Int!
  averageJobDuration: Float!
  totalURLsScraped: Int!
  successRate: Float!
  topErrors: [ErrorMetric!]
  hourlyActivity: [HourlyMetric!]
  byEntity: [EntityScraperMetrics]
}

type ErrorMetric {
  errorType: String!
  count: Int!
  urls: [String!]
}

type HourlyMetric {
  hour: String!
  jobCount: Int!
  urlsScraped: Int!
  successRate: Float!
}

type EntityScraperMetrics {
  entityId: ID
  entityName: String!
  totalJobs: Int!
  successfulJobs: Int!
  failedJobs: Int!
  totalURLsScraped: Int!
}

type ScrapedGameSummary {
  id: String!
  name: String
  gameStatus: String
  registrationStatus: String
  gameStartDateTime: String
  inDatabase: Boolean
  doNotScrape: Boolean
  error: String
}

type ScrapedGameData {
  name: String!
  gameStartDateTime: String
  gameEndDateTime: String
  gameStatus: GameStatus
  registrationStatus: String
  gameType: GameType
  gameVariant: GameVariant
  tournamentType: TournamentType
  prizepoolPaid: Float
  prizepoolCalculated: Float
  buyIn: Float
  rake: Float
  startingStack: Int
  hasGuarantee: Boolean
  guaranteeAmount: Float
  totalUniquePlayers: Int
  totalInitialEntries: Int
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  totalDuration: String
  playersRemaining: Int
  totalChipsInPlay: Float
  averagePlayerStack: Float
  seriesName: String
  isRegular: Boolean
  isSeries: Boolean
  isSatellite: Boolean
  tournamentSeriesId: ID
  seriesTitleId: ID
  isMainEvent: Boolean
  eventNumber: Int
  dayNumber: Int
  flightLetter: String
  finalDay: Boolean
  seriesYear: Int
  gameFrequency: GameFrequency
  gameTags: [String]
  levels: [ScrapedTournamentLevel!]
  breaks: [ScrapedBreak!]
  entries: [ScrapedPlayerEntry!]
  seating: [ScrapedPlayerSeating!]
  results: [ScrapedPlayerResult!]
  tables: [ScrapedTable!]
  rawHtml: String
  isNewStructure: Boolean
  structureLabel: String
  foundKeys: [String]
  venueMatch: ScrapedVenueMatch
  existingGameId: String
  doNotScrape: Boolean
  skipped: Boolean
  skipReason: String
  tournamentId: Int!
  entityId: ID
  sourceUrl: AWSURL
  s3Key: String
  source: String
  contentHash: String
  fetchedAt: AWSDateTime
  reScrapedAt: AWSDateTime
  wasForced: Boolean
  totalBuyInsCollected: Float
  rakeRevenue: Float
  prizepoolPlayerContributions: Float
  prizepoolAddedValue: Float
  prizepoolSurplus: Float
  guaranteeOverlayCost: Float
  gameProfit: Float
  venueAssignmentStatus: VenueAssignmentStatus

  # Primary error message from Lambda
  error: String
  # Alternative error message field (some responses use this)
  errorMessage: String
  # Status indicator: 'SUCCESS', 'ERROR', 'SKIPPED', etc.
  status: String
  # HTTP status code from scraper (200, 401, 403, 404, 429, 500, etc.)
  httpStatus: Int
}

type ScrapedTournamentLevel {
  levelNumber: Int!
  durationMinutes: Int
  smallBlind: Int
  bigBlind: Int
  ante: Int
}

type ScrapedBreak {
  levelNumberBeforeBreak: Int!
  durationMinutes: Int
}

type ScrapedPlayerEntry {
  name: String!
}

type ScrapedPlayerSeating {
  name: String!
  table: Int
  seat: Int
  playerStack: Int
}

type ScrapedPlayerResult {
  rank: Int!
  name: String!
  winnings: Float
  points: Float
  isQualification: Boolean
}

type ScrapedTable {
  tableName: String!
  seats: [ScrapedTableSeatData!]
}

type ScrapedTableSeatData {
  seat: Int!
  isOccupied: Boolean!
  playerName: String
  playerStack: Int
}

type ScrapedVenueMatch {
  autoAssignedVenue: ScrapedVenueMatchDetails
  suggestions: [ScrapedVenueMatchDetails!]
}

type ScrapedVenueMatchDetails {
  id: ID!
  name: String!
  score: Float!
}

type VenueMatch {
  autoAssignedVenue: ScrapedVenueMatchDetails
  suggestions: [ScrapedVenueMatchDetails]
}

type ReScrapeResult {
  name: String
  gameStartDateTime: AWSDateTime
  gameEndDateTime: AWSDateTime
  gameStatus: GameStatus
  registrationStatus: RegistrationStatus
  gameType: GameType
  gameVariant: GameVariant
  tournamentType: TournamentType
  prizepoolPaid: Float
  prizepoolCalculated: Float
  buyIn: Float
  rake: Float
  startingStack: Int
  hasGuarantee: Boolean
  guaranteeAmount: Float
  totalUniquePlayers: Int
  totalInitialEntries: Int
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  totalDuration: String
  playersRemaining: Int
  seriesName: String
  gameTags: [String]
  venueMatch: VenueMatch
  existingGameId: ID
  doNotScrape: Boolean
  sourceUrl: AWSURL
  tournamentId: Int
  entityId: ID
  s3Key: String
  reScrapedAt: AWSDateTime
}

type ScraperJobsReport {
  items: [ScraperJob]
  nextToken: String
  totalCount: Int           # Optional
  entitySummary: [EntityJobSummary]  # NEW: Optional per-entity breakdown
}

# NEW: Entity-level summary (optional but useful)
type EntityJobSummary {
  entityId: ID!
  entityName: String
  totalJobs: Int
  runningJobs: Int
  completedJobs: Int
  failedJobs: Int
}

# --- Gap Detection Types ---
type GapRange {
  start: Int!
  end: Int!
  count: Int!
}

type EntityScrapingStatus {
  entityId: ID!
  entityName: String
  lowestTournamentId: Int
  highestTournamentId: Int
  totalGamesStored: Int!
  unfinishedGameCount: Int!
  gaps: [GapRange!]!
  gapSummary: GapSummary!
  lastUpdated: AWSDateTime!
  cacheAge: Int
}

type GapSummary {
  totalGaps: Int!
  totalMissingIds: Int!
  largestGapStart: Int
  largestGapEnd: Int
  largestGapCount: Int
  coveragePercentage: Float!
}

type TournamentIdBounds {
  entityId: ID!
  lowestId: Int
  highestId: Int
  totalCount: Int!
  lastUpdated: AWSDateTime!
}

# --- S3 & Caching Types ---
type S3VersionHistory {
  s3Key: String!
  scrapedAt: AWSDateTime!
  contentHash: String
  uploadedBy: String
  contentSize: Int
}

type CachingStatsResponse {
  totalURLs: Int!
  urlsWithETags: Int!
  urlsWithLastModified: Int!
  totalCacheHits: Int!
  totalCacheMisses: Int!
  averageCacheHitRate: Float!
  storageUsedMB: Float!
  recentCacheActivity: [CacheActivityLog!]
}

type CacheActivityLog {
  url: AWSURL!
  timestamp: AWSDateTime!
  action: String!
  reason: String
}

type S3ContentResponse {
  s3Key: String!
  html: String!
  metadata: AWSJSON
  size: Int
  lastModified: AWSDateTime
}

type S3StorageHistoryResponse {
  items: [S3Storage]
  nextToken: String
}

type S3StorageListResponse {
  items: [S3Storage]
  nextToken: String
}

# --- Structure Types ---
type TournamentLevel {
  levelNumber: Int!
  durationMinutes: Int
  smallBlind: Int
  bigBlind: Int
  ante: Int
}

type Break {
  levelNumberBeforeBreak: Int!
  durationMinutes: Int
}

# --- Metrics Types ---
type ClientMetricResponse {
  success: Boolean!
  message: String
  userId: String
}

type UserMetricsSummary {
  userId: String!
  userName: String
  totalActions: Int
  totalPageViews: Int
  totalErrors: Int
  lastActive: String
  mostUsedFeature: String
}

type DatabaseMetric {
  timestamp: AWSDateTime!
  functionName: String!
  operation: String!
  table: String!
  success: Boolean!
  duration: Float
  count: Int
  entityId: String
}

type DatabaseMetricsResponse {
  metrics: [DatabaseMetric!]!
}

type AllCountsResult {
  playerCount: Int
  playerSummaryCount: Int
  playerEntryCount: Int
  playerResultCount: Int
  playerVenueCount: Int
  playerTransactionCount: Int
  playerCreditsCount: Int
  playerPointsCount: Int
  playerTicketCount: Int
  playerMarketingPreferencesCount: Int
  playerMarketingMessageCount: Int
  gameCount: Int
  tournamentStructureCount: Int
}

# --- Venue Assignment Types ---
type EntityVenueAssignmentSummary {
  entityId: ID
  entityName: String!
  totalGames: Int
  gamesWithVenue: Int
  gamesNeedingVenue: Int
}

type VenueAssignmentSummary {
  totalGames: Int
  gamesWithVenue: Int
  gamesNeedingVenue: Int
  pendingAssignments: Int
  byEntity: [EntityVenueAssignmentSummary]
}

type VenueAssignmentResult {
  success: Boolean!
  gameId: ID!
  venueId: ID!
  affectedRecords: AffectedRecords
  error: String
}

type AffectedRecords {
  gameUpdated: Boolean
  playerEntriesUpdated: Int
  playerVenueRecordsCreated: Int
  playersWithRegistrationUpdated: Int
  playerSummariesUpdated: Int
}

type BatchVenueAssignmentResult {
  successful: [VenueAssignmentResult]
  failed: [VenueAssignmentResult]
  totalProcessed: Int
}

type GamesNeedingVenueResponse {
  items: [Game]
  nextToken: String
  totalCount: Int
}

# --- Venue Reassignment Types (NEW) ---
type ReassignGameVenueResult {
  success: Boolean!
  status: String!
  message: String
  gameId: ID
  taskId: ID
  oldVenueId: ID
  newVenueId: ID
  oldEntityId: ID
  newEntityId: ID
  venueCloned: Boolean
  clonedVenueId: ID
  recordsUpdated: AWSJSON
}

type BulkReassignGameVenuesResult {
  success: Boolean!
  status: String!
  message: String
  taskId: ID
  gameCount: Int
  newVenueId: ID
  reassignEntity: Boolean
}

type GetReassignmentStatusResult {
  success: Boolean!
  message: String
  task: BackgroundTaskInfo
}

type BackgroundTaskInfo {
  id: ID!
  status: BackgroundTaskStatus!
  taskType: BackgroundTaskType!
  targetCount: Int
  processedCount: Int
  progressPercent: Float
  result: AWSJSON
  errorMessage: String
  createdAt: AWSDateTime!
  startedAt: AWSDateTime
  completedAt: AWSDateTime
}

# --- Social Pulse Response Types ---
type SocialFeedConnection {
  items: [SocialPost!]!
  nextToken: String
  totalCount: Int
}

type SocialPostConnection {
  items: [SocialPost!]!
  nextToken: String
}

type SocialAccountConnection {
  items: [SocialAccount!]!
  nextToken: String
}

type SocialAccountMetrics {
  accountId: ID!
  totalPosts: Int!
  totalEngagement: Int!
  avgLikesPerPost: Float
  avgCommentsPerPost: Float
  avgSharesPerPost: Float
  postsThisPeriod: Int
  engagementGrowth: Float
  topPerformingPosts: [SocialPost!]
}

type SocialScrapeResult {
  success: Boolean!
  message: String
  postsFound: Int
  newPostsAdded: Int
}

type SyncPageInfoResult {
  success: Boolean!
  message: String
  logoUrl: String
}

# --- Misc Response Types ---
type RefreshResponse {
  message: String!
  status: String!
}

type SaveGameResult {
  success: Boolean!
  gameId: ID
  action: String!
  message: String
  warnings: [String]
  playerProcessingQueued: Boolean
  playerProcessingReason: String
  venueAssignment: SaveVenueAssignmentInfo
  seriesAssignment: SaveSeriesAssignmentInfo
  fieldsUpdated: [String]
  wasEdited: Boolean
}

type SaveVenueAssignmentInfo {
  venueId: ID
  venueName: String
  status: VenueAssignmentStatus
  confidence: Float
}

type SaveSeriesAssignmentInfo {
  tournamentSeriesId: ID
  seriesName: String
  status: SeriesAssignmentStatus
  confidence: Float
}

# --- Connection Types (Paginated) ---
type S3StorageConnection {
  items: [S3Storage!]!
  nextToken: String
}

type ScraperJobConnection {
  items: [ScraperJob!]
  nextToken: String
}

type ScrapeURLConnection {
  items: [ScrapeURL]
  nextToken: String
  totalCount: Int           # Optional: for showing total matching records
}

type UnfinishedGamesConnection {
  items: [Game!]!
  nextToken: String
  totalCount: Int!
}

# ===================================================================
# 8. INPUT TYPES
# ===================================================================

# --- Input Types for User Management ---

input CreateUserInput {
  id: ID
  username: String!
  email: String!
  role: UserRole!
  firstName: String
  lastName: String
  phone: String
  allowedPages: [String]
  allowedEntityIds: [ID]
  allowedVenueIds: [ID]
  defaultEntityId: ID
  isActive: Boolean
}

input UpdateUserInput {
  id: ID!
  username: String
  email: String
  role: UserRole
  firstName: String
  lastName: String
  phone: String
  avatar: AWSURL
  allowedPages: [String]
  allowedEntityIds: [ID]
  allowedVenueIds: [ID]
  defaultEntityId: ID
  isActive: Boolean
  mustChangePassword: Boolean
}

input ResetUserPasswordInput {
  userId: ID!
  temporaryPassword: String
  sendEmail: Boolean
}

# --- Venue Reassignment Input Types (NEW) ---

input ReassignGameVenueInput {
  gameId: ID!
  newVenueId: ID!
  entityId: ID!
  reassignEntity: Boolean!
  initiatedBy: String
}

input BulkReassignGameVenuesInput {
  gameIds: [ID!]!
  newVenueId: ID!
  entityId: ID!
  reassignEntity: Boolean!
  initiatedBy: String
}

# --- Existing Input Types ---

input ConsolidationPreviewInput {
  gameData: GamePreviewDataInput!
  existingGameId: ID
  includeSiblingDetails: Boolean
}

input GamePreviewDataInput {
  name: String!
  tournamentId: Int
  venueId: ID
  entityId: ID
  buyIn: Float
  gameStatus: GameStatus
  gameStartDateTime: AWSDateTime
  tournamentSeriesId: ID
  eventNumber: Int
  dayNumber: Int
  flightLetter: String
  finalDay: Boolean
  isSeries: Boolean
  seriesName: String
  isMainEvent: Boolean
  totalUniquePlayers: Int
  totalInitialEntries: Int
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  prizepoolPaid: Float
  prizepoolCalculated: Float
  gameEndDateTime: AWSDateTime
}

input ClientMetricInput {
  metricName: String!
  value: Float!
  unit: String!
  dimensions: String
  timestamp: String
  metadata: String
}

input ManualHTMLUploadInput {
  htmlContent: String!
  url: AWSURL!
  tournamentId: Int!
  entityId: ID!
  notes: String
  uploadedBy: String!
}

input ReScrapeFromCacheInput {
  s3Key: String!
  saveToDatabase: Boolean
}

input UploadManualHTMLInput {
  htmlContent: String!
  url: AWSURL!
  tournamentId: Int!
  entityId: ID!
  notes: String
  uploadedBy: String
}

input VenueAssignment {
  gameId: ID!
  venueId: ID!
}

input SaveTournamentInput {
  sourceUrl: AWSURL!
  venueId: ID
  existingGameId: ID
  doNotScrape: Boolean
  data: ScrapedGameDataInput!
  originalScrapedData: AWSJSON
  venueAssignmentStatus: VenueAssignmentStatus
  requiresVenueAssignment: Boolean
  suggestedVenueName: String
  venueAssignmentConfidence: Float
  entityId: ID
}

input ScrapedGameDataInput {
  name: String!
  gameStartDateTime: String
  gameEndDateTime: String
  gameStatus: GameStatus
  registrationStatus: RegistrationStatus
  gameVariant: GameVariant
  gameType: GameType
  prizepoolPaid: Float
  prizepoolCalculated: Float
  totalUniquePlayers: Int
  totalInitialEntries: Int
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  totalDuration: String
  gameTags: [String]
  tournamentType: TournamentType
  buyIn: Float
  rake: Float
  startingStack: Int
  hasGuarantee: Boolean
  guaranteeAmount: Float
  levels: [ScrapedTournamentLevelInput!]
}

input ScrapedTournamentLevelInput {
  levelNumber: Int!
  durationMinutes: Int
  smallBlind: Int
  bigBlind: Int
  ante: Int
  breakMinutes: Int
}

input StartScraperJobInput {
  triggerSource: ScraperJobTriggerSource!
  maxGames: Int
  targetURLs: [String]
  startId: Int
  endId: Int
  isFullScan: Boolean
  triggeredBy: String
  entityId: ID
  isSequential: Boolean
}

input SaveGameInput {
  source: DataSourceInfoInput!
  game: SaveGameDataInput!
  players: SavePlayerDataInput
  venue: VenueReferenceInput
  series: SeriesReferenceInput
  options: SaveProcessingOptionsInput
  auditTrail: String
}

input DataSourceInfoInput {
  type: DataSource!
  sourceId: String!
  entityId: ID!
  fetchedAt: AWSDateTime!
  contentHash: String
  wasEdited: Boolean
}

input SaveGameDataInput {
  tournamentId: Int
  existingGameId: ID
  name: String!
  gameType: GameType!
  gameVariant: GameVariant
  gameStatus: GameStatus!
  gameStartDateTime: AWSDateTime!
  gameEndDateTime: AWSDateTime
  registrationStatus: RegistrationStatus
  gameFrequency: GameFrequency
  buyIn: Float
  rake: Float
  guaranteeAmount: Float
  hasGuarantee: Boolean
  startingStack: Int
  prizepoolPaid: Float
  prizepoolCalculated: Float
  totalUniquePlayers: Int
  totalInitialEntries: Int
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  playersRemaining: Int
  totalChipsInPlay: Float
  averagePlayerStack: Float
  totalDuration: String
  totalBuyInsCollected: Float
  rakeRevenue: Float
  prizepoolPlayerContributions: Float
  prizepoolAddedValue: Float
  prizepoolSurplus: Float
  guaranteeOverlayCost: Float
  gameProfit: Float
  tournamentType: TournamentType
  isSeries: Boolean
  seriesName: String
  tournamentSeriesId: ID
  isMainEvent: Boolean
  eventNumber: Int
  dayNumber: Int
  flightLetter: String
  finalDay: Boolean
  isSatellite: Boolean
  isRegular: Boolean
  gameTags: [String]
  levels: AWSJSON
  venueFee: Float
  venueAssignmentStatus: VenueAssignmentStatus
}

input SavePlayerDataInput {
  allPlayers: [SavePlayerInfoInput!]!
  totalInitialEntries: Int!
  totalEntries: Int!
  totalUniquePlayers: Int!
  hasCompleteResults: Boolean!
  totalPrizesPaid: Float
  hasEntryList: Boolean
  hasSeatingData: Boolean
}

input SavePlayerInfoInput {
  name: String!
  rank: Int
  winnings: Float
  points: Float
  isQualification: Boolean
  rebuys: Int
  addons: Int
}

input VenueReferenceInput {
  venueId: ID
  venueName: String
  suggestedVenueId: ID
  confidence: Float
}

input SeriesReferenceInput {
  seriesId: ID
  seriesName: String
  suggestedSeriesId: ID
  year: Int
  confidence: Float
  isMainEvent: Boolean
  eventNumber: Int
  dayNumber: Int
  flightLetter: String
  finalDay: Boolean
}

input SaveProcessingOptionsInput {
  skipPlayerProcessing: Boolean
  forceUpdate: Boolean
  validateOnly: Boolean
  doNotScrape: Boolean
  priority: String
}

# --- Social Pulse Input Types ---

input AddSocialAccountInput {
  platform: SocialPlatform!
  accountUrl: AWSURL!
  accountName: String!
  accountHandle: String
  platformAccountId: String
  entityId: ID
  venueId: ID
  scrapeFrequencyMinutes: Int
}

input UpdateSocialAccountInput {
  id: ID!
  accountName: String
  accountHandle: String
  isScrapingEnabled: Boolean
  scrapeFrequencyMinutes: Int
  status: SocialAccountStatus
  entityId: ID
  venueId: ID
  profileImageUrl: AWSURL
  bio: String
}

input SchedulePostInput {
  content: String!
  mediaUrls: [AWSURL]
  linkUrl: AWSURL
  scheduledFor: AWSDateTime!
  targetAccountIds: [ID!]!
  entityId: ID!
  linkedGameId: ID
  templateType: String
}

input UpdateSocialPostInput {
  id: ID!
  status: SocialPostStatus
  isTournamentRelated: Boolean
  linkedGameId: ID
  tags: [String]
  contentCategory: String
}

# ===================================================================
# 9. ROOT OPERATIONS
# ===================================================================

type Query {
  # --- User Management Queries ---
  adminListUsers(role: UserRole, isActive: Boolean, limit: Int, nextToken: String): UsersConnection
    @function(name: "userManagement-${env}")
    @auth(rules: [{ allow: groups, groups: ["SUPER_ADMIN"] }])

  getUserById(id: ID!): User
    @function(name: "userManagement-${env}")
    @auth(rules: [{ allow: groups, groups: ["SUPER_ADMIN"] }])

  # --- Consolidation Queries ---
  previewConsolidation(input: ConsolidationPreviewInput!): ConsolidationPreviewResult!
    @function(name: "tournamentConsolidator-${env}")

  # --- Scraper & Jobs ---
  fetchTournamentDataRange(startId: Int!, endId: Int!): [ScrapedGameSummary!]
    @function(name: "webScraperFunction-${env}")

  getScraperControlState(entityId: ID): ScraperControlResponse
    @function(name: "autoScraper-${env}")

  fetchUpdateCandidates: [String!]
    @function(name: "webScraperFunction-${env}")

  getScraperJobsReport(
    entityId: ID              # NEW: Filter by single entity
    entityIds: [ID]           # NEW: Filter by multiple entities
    status: ScraperJobStatus
    limit: Int
    nextToken: String
  ): ScraperJobsReport
    @function(name: "scraperManagement-${env}")

  fetchScrapeURLDetails(url: AWSURL!): ScrapeURL
    @function(name: "scraperManagement-${env}")

  searchScrapeURLs(
    entityId: ID              # NEW: Filter by single entity
    entityIds: [ID]           # NEW: Filter by multiple entities  
    status: ScrapeURLStatus
    limit: Int
    nextToken: String
  ): ScrapeURLConnection
    @function(name: "scraperManagement-${env}")

  getScraperMetrics(
    entityId: ID              # NEW: Filter by single entity
    entityIds: [ID]           # NEW: Filter by multiple entities
    timeRange: TimeRange
  ): ScraperMetrics
    @function(name: "scraperManagement-${env}")

  getUpdateCandidateURLs(
    entityId: ID              # NEW
    entityIds: [ID]           # NEW
    limit: Int
  ): [ScrapeURL]
    @function(name: "scraperManagement-${env}")

  scrapeGame(url: AWSURL!, entityId: ID, venueId: ID, doNotScrape: Boolean): ScrapedGameData
    @function(name: "singleGameScraper-${env}")

  scrapeBulkGames(startId: Int!, endId: Int!, entityId: ID): [ScrapedGameSummary]
    @function(name: "bulkGamesScraper-${env}")

  listScraperJobs(entityId: ID, status: ScraperJobStatus, startTime: AWSDateTime, endTime: AWSDateTime, limit: Int, nextToken: String): ScraperJobConnection
    @function(name: "scraperJobQuery-${env}")

  listScrapeURLs(entityId: ID, status: ScrapeURLStatus, limit: Int, nextToken: String): ScrapeURLConnection
    @function(name: "scrapeURLQuery-${env}")

  # --- Venue & Assignments ---
  listGamesNeedingVenue(limit: Int, nextToken: String, entityId: ID): GamesNeedingVenueResponse
    @function(name: "venueAssignmentService-${env}")

  getVenueAssignmentSummary(entityId: ID): VenueAssignmentSummary
    @function(name: "venueAssignmentService-${env}")

  # --- Venue Reassignment Queries (NEW) ---
  getReassignmentStatus(taskId: ID!): GetReassignmentStatusResult
    @function(name: "venueAssignmentService-${env}")

  getVenueClones(canonicalVenueId: ID!): [Venue]
    @function(name: "venueAssignmentService-${env}")

  findVenueForEntity(canonicalVenueId: ID!, entityId: ID!): Venue
    @function(name: "venueAssignmentService-${env}")

  # --- Metrics ---
  getMyMetrics(timeRange: String): UserMetricsSummary
    @function(name: "getUserMetrics-${env}")
    @auth(rules: [{ allow: private }])

  getUserMetrics(userId: String!, timeRange: String): UserMetricsSummary
    @function(name: "getUserMetrics-${env}")
    @auth(rules: [{ allow: groups, groups: ["Admin"] }])

  getDatabaseMetrics(timeRange: String): DatabaseMetricsResponse
    @function(name: "getDatabaseMetrics-${env}")

  getVenueMetricsPreview(input: VenueMetricsPreviewInput!): VenueMetricsPreview
    @function(name: "venueDetailsUpdater-${env}")

  # --- Counts ---
  playerCount: Int
    @function(name: "getModelCount-${env}")

  playerSummaryCount: Int
    @function(name: "getModelCount-${env}")

  playerEntryCount: Int
    @function(name: "getModelCount-${env}")

  playerResultCount: Int
    @function(name: "getModelCount-${env}")

  playerVenueCount: Int
    @function(name: "getModelCount-${env}")

  playerTransactionCount: Int
    @function(name: "getModelCount-${env}")

  playerCreditsCount: Int
    @function(name: "getModelCount-${env}")

  playerPointsCount: Int
    @function(name: "getModelCount-${env}")

  playerTicketCount: Int
    @function(name: "getModelCount-${env}")

  playerMarketingPreferencesCount: Int
    @function(name: "getModelCount-${env}")

  playerMarketingMessageCount: Int
    @function(name: "getModelCount-${env}")

  gameCount: Int
    @function(name: "getModelCount-${env}")

  tournamentStructureCount: Int
    @function(name: "getModelCount-${env}")

  getAllCounts: AllCountsResult
    @function(name: "getModelCount-${env}")

  # --- S3 & Storage ---
  getS3StorageHistory(tournamentId: Int!, entityId: ID!, limit: Int): S3StorageConnection
    @function(name: "s3ManagementFunction-${env}")

  viewS3Content(s3Key: String!): S3ContentResponse
    @function(name: "s3ManagementFunction-${env}")

  getCachingStats(entityId: ID!, timeRange: TimeRange): CachingStatsResponse
    @function(name: "s3ManagementFunction-${env}")

  listStoredHTML(url: AWSURL!, limit: Int): S3StorageConnection
    @function(name: "s3ManagementFunction-${env}")

  # --- Game Tracker & Gaps ---
  getTournamentIdBounds(entityId: ID!): TournamentIdBounds
    @function(name: "gameIdTracker-${env}")

  getEntityScrapingStatus(entityId: ID!, forceRefresh: Boolean, startId: Int, endId: Int): EntityScrapingStatus
    @function(name: "gameIdTracker-${env}")

  findTournamentIdGaps(entityId: ID!, startId: Int, endId: Int, maxGapsToReturn: Int): [GapRange!]
    @function(name: "gameIdTracker-${env}")

  getUnfinishedGamesByEntity(entityId: ID!, limit: Int, nextToken: String): UnfinishedGamesConnection
    @function(name: "gameIdTracker-${env}")

  listExistingTournamentIds(entityId: ID!, startId: Int, endId: Int, limit: Int): [Int!]
    @function(name: "gameIdTracker-${env}")
}

type Mutation {
  # --- User Management Mutations ---
  adminCreateUser(input: CreateUserInput!): UserManagementResponse
    @function(name: "userManagement-${env}")
    @auth(rules: [{ allow: groups, groups: ["SUPER_ADMIN"] }])

  adminUpdateUser(input: UpdateUserInput!): UserManagementResponse
    @function(name: "userManagement-${env}")
    @auth(rules: [{ allow: groups, groups: ["SUPER_ADMIN"] }])

  adminResetPassword(input: ResetUserPasswordInput!): ResetPasswordResponse
    @function(name: "userManagement-${env}")
    @auth(rules: [{ allow: groups, groups: ["SUPER_ADMIN"] }])

  adminDeactivateUser(userId: ID!): UserManagementResponse
    @function(name: "userManagement-${env}")
    @auth(rules: [{ allow: groups, groups: ["SUPER_ADMIN"] }])

  adminReactivateUser(userId: ID!): UserManagementResponse
    @function(name: "userManagement-${env}")
    @auth(rules: [{ allow: groups, groups: ["SUPER_ADMIN"] }])

  # --- Scraper Controls ---
  fetchTournamentData(url: AWSURL, s3Key: String, forceRefresh: Boolean, scraperApiKey: String, entityId: ID): ScrapedGameData
    @function(name: "webScraperFunction-${env}")

  saveTournamentData(input: SaveTournamentInput!): Game
    @function(name: "webScraperFunction-${env}")

  controlScraperOperation(operation: ScraperOperation!, entityId: ID): ScraperControlResponse
    @function(name: "autoScraper-${env}")

  triggerAutoScraping(maxGames: Int, entityId: ID!): ScraperControlResponse
    @function(name: "autoScraper-${env}")

  startScraperJob(input: StartScraperJobInput!): ScraperJob
    @function(name: "scraperManagement-${env}")

  cancelScraperJob(jobId: String!): ScraperJob
    @function(name: "scraperManagement-${env}")

  modifyScrapeURLStatus(url: AWSURL!, status: ScrapeURLStatus, doNotScrape: Boolean): ScrapeURL
    @function(name: "scraperManagement-${env}")

  bulkModifyScrapeURLs(urls: [AWSURL!]!, status: ScrapeURLStatus, doNotScrape: Boolean): [ScrapeURL!]
    @function(name: "scraperManagement-${env}")

  reScrapeFromCache(input: ReScrapeFromCacheInput!): ScrapedGameData
    @function(name: "webScraperFunction-${env}")

  forceRefreshScrape(url: AWSURL!): ScrapedGameData

  clearURLCache(url: AWSURL!): Boolean

  saveGame(input: SaveGameInput!): SaveGameResult!
    @function(name: "saveGameFunction-${env}")

  recalculateVenueDetails(input: RecalculateVenueDetailsInput!): VenueMetricsResult
    @function(name: "venueDetailsUpdater-${env}")

  # --- Venue Assignment ---
  assignVenueToGame(gameId: ID!, venueId: ID!): VenueAssignmentResult
    @function(name: "venueAssignmentService-${env}")

  batchAssignVenues(assignments: [VenueAssignment!]!): BatchVenueAssignmentResult
    @function(name: "venueAssignmentService-${env}")

  # --- Venue Reassignment (NEW) ---
  reassignGameVenue(input: ReassignGameVenueInput!): ReassignGameVenueResult
    @function(name: "venueAssignmentService-${env}")

  bulkReassignGameVenues(input: BulkReassignGameVenuesInput!): BulkReassignGameVenuesResult
    @function(name: "venueAssignmentService-${env}")

  # --- Misc & S3 ---
  publishClientMetrics(metrics: [ClientMetricInput!]!): ClientMetricResponse
    @function(name: "publishClientMetrics-${env}")
    @auth(rules: [{ allow: private }])

  uploadManualHTML(input: ManualHTMLUploadInput!): S3Storage

  # --- Social Pulse Mutations ---
  triggerSocialScrape(socialAccountId: ID!): SocialScrapeResult
    @function(name: "socialFetcher-${env}")

  triggerFullSync(socialAccountId: ID!): SocialScrapeResult
    @function(name: "socialFetcher-${env}")

  syncPageInfo(socialAccountId: ID!, forceRefresh: Boolean): SyncPageInfoResult
    @function(name: "socialFetcher-${env}")
}

type Subscription {
  onScraperJobUpdate(jobId: String): ScraperJob
    @aws_subscribe(mutations: ["startScraperJob", "cancelScraperJob"])

  onScrapeURLStatusChange(url: AWSURL): ScrapeURL
    @aws_subscribe(mutations: ["modifyScrapeURLStatus", "bulkModifyScrapeURLs"])
}