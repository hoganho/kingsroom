# ===================================================================
# 1. CORE ENUMS
# - Defines the constant values used across the entire schema.
# ===================================================================

enum DataSource { SCRAPE, API, MANUAL }
enum AssetCondition { NEW, GOOD, FAIR, POOR, RETIRED }
enum VenueStatus { ACTIVE, INACTIVE, PENDING }
enum GameType { TOURNAMENT, CASH_GAME }
enum GameStatus { INITIATING, SCHEDULED, REGISTERING, RUNNING, CANCELLED, FINISHED, NOT_IN_USE }
enum GameVariant { NLHE, PLO, PLO5, PLO6 }
enum GameFrequency { DAILY, WEEKLY, FORTNIGHTLY, MONTHLY, QUARTERLY, YEARLY, UNKNOWN }
enum RegistrationStatus { SCHEDULED, OPEN, FINAL, CLOSED, N_A }
enum TournamentType { FREEZEOUT, REBUY, SATELLITE, DEEPSTACK }
enum PaymentSourceType { CASH, SQUARE, CREDIT, UNKNOWN }
enum PlayerAccountStatus { ACTIVE, SUSPENDED, PENDING_VERIFICATION }
enum PlayerAccountCategory { NEW, RECREATIONAL, REGULAR, VIP, LAPSED }
enum SeriesStatus { LIVE, SCHEDULED, COMPLETED }
enum PlayerTargetingClassification { NotPlayed, Active_EL, Active, Retain_Inactive31_60d, Retain_Inactive61_90d, Churned_91_120d, Churned_121_180d, Churned_181_360d, Churned_361d }
enum PlayerVenueTargetingClassification { Active_EL, Active, Retain_Inactive31_60d, Retain_Inactive61_90d, Churned_91_120d, Churned_121_180d, Churned_181_360d, Churned_361d }
enum TransactionType { BUY_IN, DEPOSIT, TICKET_AWARD, TICKET_REDEMPTION, CASH_AWARD, QUALIFICATION, WITHDRAWAL }
enum MessageStatus { SENT, DELIVERED, FAILED, READ }
enum UserRole { SUPER_ADMIN, ADMIN, VENUE_MANAGER, TOURNAMENT_DIRECTOR, MARKETING }
enum StaffRole { DEALER, FLOOR_MANAGER, SERVICE, TOURNAMENT_DIRECTOR }
enum TicketStatus { ACTIVE, EXPIRED, USED }

# ===================================================================
# 2. SCRAPING & DATA MANAGEMENT
# - Models for managing the data ingestion and scraping process.
# ===================================================================

type ScrapeStructure @model @auth(rules: [{ allow: private }]) {
  id: ID! # SHA-256 hash of the sorted fields array
  fields: [String]!
  structureLabel: String! # Combo of gameStatus and registrationStatus
  occurrenceCount: Int!
  firstSeenAt: AWSDateTime!
  lastSeenAt: AWSDateTime!
  exampleUrl: AWSURL
}

type DataSync @model @auth(rules: [{ allow: private }]) {
  id: ID!
  syncedAt: AWSDateTime!
  method: DataSource!
  sourceUrl: AWSURL
  title: String
  content: String
}

# ===================================================================
# 3. VENUE & LOCATION MANAGEMENT
# - Core models for physical locations where games are held.
# ===================================================================

type Venue @model @auth(rules: [{ allow: private }]) {
  # --- Identification & Core Details ---
  id: ID!
  venueNumber: Int! @index(name: "byVenueNumber", sortKeyFields: ["name"])
  name: String!
  aliases: [String]
  address: String
  city: String
  country: String

  # --- Relationships ---
  details: VenueDetails @hasOne
  assets: [Asset] @hasMany(indexName: "byVenue", fields: ["id"])
  games: [Game] @hasMany(indexName: "byVenue", fields: ["id"])
  series: [TournamentSeries] @hasMany(indexName: "byVenue", fields: ["id"])
  playerMemberships: [PlayerVenue] @hasMany(indexName: "byVenue", fields: ["id"])
}

type VenueDetails @model @auth(rules: [{ allow: private }]) {
  # --- Core Details & Status ---
  id: ID!
  startDate: AWSDate!
  status: VenueStatus!
  lastCustomerSuccessVisit: AWSDate
  
  # --- Aggregated Metrics ---
  totalGamesHeld: Int
  averagePlayersPerGame: Float
  gameNights: [String] # e.g., ["Monday", "Friday"]

  # --- Relationships ---
  venueId: ID! @index(name: "byVenue")
  venue: Venue @belongsTo(fields: ["venueId"])
}

# ===================================================================
# 4. TOURNAMENT SERIES MANAGEMENT
# - Models for organizing multi-day or themed tournament events.
# ===================================================================

type TournamentSeriesTitle @model @auth(rules: [{ allow: private }]) {
  id: ID!
  title: String!
  aliases: [String]
  # --- Relationships ---
  seriesInstances: [TournamentSeries] @hasMany(indexName: "byTournamentSeriesTitle", fields: ["id"])
}

type TournamentSeries @model @auth(rules: [{ allow: private }]) {
  # --- Identification & Core Details ---
  id: ID!
  name: String! # e.g., "Sydney Millions 2025"
  year: Int!
  status: SeriesStatus!

  # --- Scheduling & Content ---
  startDate: AWSDate
  endDate: AWSDate
  events: [String]
  numberOfEvents: Int

  # --- Financials ---
  guaranteedPrizepool: Float
  estimatedPrizepool: Float
  actualPrizepool: Float

  # --- Relationships ---
  tournamentSeriesTitleId: ID! @index(name: "byTournamentSeriesTitle", sortKeyFields: ["year"])
  title: TournamentSeriesTitle @belongsTo(fields: ["tournamentSeriesTitleId"])
  venueId: ID! @index(name: "byVenue")
  venue: Venue @belongsTo(fields: ["venueId"])
  games: [Game] @hasMany(indexName: "byTournamentSeries", fields: ["id"])
}

# ===================================================================
# 5. GAME & STRUCTURE MANAGEMENT
# - The central models for individual games and their structures.
# ===================================================================

type Game @model @auth(rules: [{ allow: private }]) {
  # --- Core Identification ---
  id: ID!
  name: String!
  gameType: GameType!
  gameVariant: GameVariant!
  gameStatus: GameStatus!

  # --- Scheduling & Timestamps ---
  gameStartDateTime: AWSDateTime!
  gameEndDateTime: AWSDateTime
  registrationStatus: String
  totalDuration: String
  gameFrequency: GameFrequency

  # --- Financials & Buy-in ---
  buyIn: Float
  rake: Float
  startingStack: Int
  hasGuarantee: Boolean
  guaranteeAmount: Float

  # --- Aggregates & Results ---
  prizepool: Float
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int

  # --- Calculated Financial Metrics ---
  revenueByBuyIns: Float
  totalRake: Float
  profitLoss: Float
  guaranteeOverlay: Float
  guaranteeSurplus: Float

  # --- Live Game Data ---
  playersRemaining: Int
  totalChipsInPlay: Float
  averagePlayerStack: Float

  # --- Categorization & Metadata ---
  tournamentType: TournamentType
  isRegular: Boolean
  isSeries: Boolean
  isSatellite: Boolean
  seriesName: String # Denormalized for faster access
  gameTags: [String]

  # --- Data Source & Verification ---
  sourceUrl: AWSURL @index(name: "bySourceUrl", queryField: "gameBySourceUrl")
  doNotScrape: Boolean
  sourceDataIssue: Boolean
  gameDataVerified: Boolean

  # --- Relationships ---
  venueId: ID! @index(name: "byVenue", sortKeyFields: ["gameStartDateTime"])
  venue: Venue @belongsTo(fields: ["venueId"])
  tournamentSeriesId: ID @index(name: "byTournamentSeries")
  tournamentSeries: TournamentSeries @belongsTo(fields: ["tournamentSeriesId"])
  tournamentStructureId: ID @index(name: "byTournamentStructure")
  tournamentStructure: TournamentStructure @belongsTo(fields: ["tournamentStructureId"])
  cashStructureId: ID @index(name: "byCashStructure")
  cashStructure: CashStructure @belongsTo(fields: ["cashStructureId"])
  playerResults: [PlayerResult] @hasMany(indexName: "byGame", fields: ["id"])
}

type TournamentStructure @model @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String! # e.g., "Standard Daily Structure"
  description: String
  levels: [TournamentLevelData] # Embedded array of levels
  games: [Game] @hasMany(indexName: "byTournamentStructure", fields: ["id"])
}

type TournamentLevelData { # Not a @model, embedded type
  levelNumber: Int!
  durationMinutes: Int!
  smallBlind: Int!
  bigBlind: Int!
  ante: Int
  breakMinutes: Int
}

type CashStructure @model @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String! # e.g., "$1/$2 NLHE"
  smallBlind: Float!
  bigBlind: Float!
  minBuyIn: Float!
  maxBuyIn: Float!

  # --- Relationships ---
  rakeStructureId: ID! @index(name: "byRakeStructure")
  rakeStructure: RakeStructure @belongsTo(fields: ["rakeStructureId"])
  games: [Game] @hasMany(indexName: "byCashStructure", fields: ["id"])
}

type RakeStructure @model @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  rakePercentage: Float!
  maxRake: Float!
  cashStructures: [CashStructure] @hasMany(indexName: "byRakeStructure", fields: ["id"])
}

# ===================================================================
# 6. PLAYER & PROFILE MANAGEMENT
# - Models for player information, stats, and engagement.
# ===================================================================

type Player @model @auth(rules: [{ allow: private }]) {
  # --- Personal Information ---
  id: ID!
  firstName: String!
  givenName: String
  lastName: String
  email: String @index(name: "byEmail", queryField: "playerByEmail")
  phone: String

  # --- Account Management & Status ---
  creationDate: AWSDateTime!
  status: PlayerAccountStatus!
  category: PlayerAccountCategory!
  tier: String # e.g., "Bronze", "Silver", "Gold"

  # --- Engagement Metrics ---
  lastPlayedDate: AWSDate
  targetingClassification: PlayerTargetingClassification!
  
  # --- Relationships ---
  registrationVenueId: ID! @index(name: "byVenue")
  summary: PlayerSummary @hasOne
  transactions: [PlayerTransaction] @hasMany(indexName: "byPlayer", fields: ["id"])
  results: [PlayerResult] @hasMany(indexName: "byPlayer", fields: ["id"])
  tickets: [PlayerTicket] @hasMany(indexName: "byPlayer", fields: ["id"])
  venueMemberships: [PlayerVenue] @hasMany(indexName: "byPlayer", fields: ["id"])
  marketingPreferences: PlayerMarketingPreferences @hasOne
}

type PlayerSummary @model @auth(rules: [{ allow: private }]) {
  # --- Identification ---
  id: ID!
  playerId: ID! @index(name: "byPlayer")

  # --- High-Level Stats ---
  sessionsPlayed: Int
  tournamentsPlayed: Int
  cashGamesPlayed: Int
  venuesVisited: [ID]

  # --- Tournament Financials ---
  tournamentWinnings: Float
  tournamentBuyIns: Float
  tournamentITM: Int
  tournamentsCashed: Int
  
  # --- Cash Game Financials ---
  cashGameWinnings: Float
  cashGameBuyIns: Float

  # --- Overall Financials ---
  totalWinnings: Float
  totalBuyIns: Float
  netBalance: Float

  # --- Metadata & Relationships ---
  lastUpdated: AWSDateTime!
  player: Player @belongsTo(fields: ["playerId"])
}

type PlayerResult @model @auth(rules: [{ allow: private }]) {
  id: ID!
  finishingPlace: Int
  isMultiDayQualification: Boolean
  prizeWon: Boolean
  amountWon: Float
  totalRunners: Int

  # --- Relationships ---
  playerId: ID! @index(name: "byPlayer")
  player: Player @belongsTo(fields: ["playerId"])
  gameId: ID! @index(name: "byGame")
  game: Game @belongsTo(fields: ["gameId"])
}

type PlayerVenue @model @auth(rules: [{ allow: private }]) {
  id: ID!
  totalGamesPlayed: Int
  averageBuyIn: Float
  firstPlayedDate: AWSDate
  lastPlayedDate: AWSDate
  targetingClassification: PlayerVenueTargetingClassification!

  # --- Relationships ---
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["venueId"])
  player: Player @belongsTo(fields: ["playerId"])
  venueId: ID! @index(name: "byVenue", sortKeyFields: ["playerId"])
  venue: Venue @belongsTo(fields: ["venueId"])
}

type PlayerTransaction @model @auth(rules: [{ allow: private }]) {
  id: ID!
  type: TransactionType!
  amount: Float!
  rake: Float # Rake component of a buy-in
  paymentSource: PaymentSourceType!
  transactionDate: AWSDateTime!
  notes: String

  # --- Relationships ---
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["transactionDate"])
  player: Player @belongsTo(fields: ["playerId"])
  gameId: ID @index(name: "byGame") # Optional link to a game
}

# ===================================================================
# 7. TICKETS & MARKETING
# - Models for player rewards and communication.
# ===================================================================

type TicketTemplate @model @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  description: String
  value: Float!
  validityDays: Int!
  originGameId: ID
  targetGameId: ID
  playerTickets: [PlayerTicket] @hasMany(indexName: "byTicketTemplate", fields: ["id"])
}

type PlayerTicket @model @auth(rules: [{ allow: private }]) {
  id: ID!
  assignedAt: AWSDateTime!
  expiryDate: AWSDateTime!
  status: TicketStatus!
  usedInGameId: ID

  # --- Relationships ---
  playerId: ID! @index(name: "byPlayer")
  player: Player @belongsTo(fields: ["playerId"])
  ticketTemplateId: ID! @index(name: "byTicketTemplate")
  ticketTemplate: TicketTemplate @belongsTo(fields: ["ticketTemplateId"])
}

type MarketingMessage @model @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String! # Internal campaign name
  subject: String
  emailBody: String
  smsBody: String
  sentMessages: [PlayerMarketingMessage] @hasMany(indexName: "byMarketingMessage", fields: ["id"])
}

type PlayerMarketingMessage @model @auth(rules: [{ allow: private }]) {
  id: ID!
  status: MessageStatus!
  sentAt: AWSDateTime!

  # --- Relationships ---
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["sentAt"])
  marketingMessageId: ID! @index(name: "byMarketingMessage")
}

type PlayerMarketingPreferences @model @auth(rules: [{ allow: private }]) {
  id: ID!
  optOutSms: Boolean
  optOutEmail: Boolean

  # --- Relationships ---
  playerId: ID! @index(name: "byPlayer")
  player: Player @belongsTo(fields: ["playerId"])
}

# ===================================================================
# 8. STAFF, USER & ADMIN
# - Models for internal users and system administration.
# ===================================================================

type User @model @auth(rules: [
  { allow: owner, ownerField: "id", operations: [read, update] },
  { allow: private, operations: [read] },
  { allow: groups, groups: ["SUPER_ADMIN"], operations: [create, read, update, delete] }
]) {
  id: ID! # Uses Cognito username (sub)
  username: String!
  email: String!
  role: UserRole!
  preferences: [UserPreference] @hasMany(indexName: "byUser", fields: ["id"])
}

type UserPreference @model @auth(rules: [{ allow: owner, ownerField: "userId" }]) {
  id: ID!
  page: String!
  widget: String!
  preference: AWSJSON
  userId: ID! @index(name: "byUser")
}

type Staff @model @auth(rules: [{ allow: private }]) {
  id: ID!
  firstName: String!
  lastName: String
  role: StaffRole!
  assignedVenueId: ID @index(name: "byVenue")
}

# ===================================================================
# 9. ANCILLARY MODELS
# - Other supporting models for assets and social media.
# ===================================================================

type Asset @model @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  type: String! # e.g., "Playing Cards", "Poker Table"
  condition: AssetCondition!
  acquiredDate: AWSDate!
  lastCheckedDate: AWSDate!

  # --- Relationships ---
  venueId: ID! @index(name: "byVenue")
  venue: Venue @belongsTo(fields: ["venueId"])
}

type SocialAccount @model @auth(rules: [{ allow: private }]) {
  id: ID!
  platform: String! # e.g., "Facebook", "Instagram"
  accountName: String!
  apiKey: String
  apiSecret: String
}

type SocialPost @model @auth(rules: [{ allow: private }]) {
  id: ID!
  content: String!
  imageUrl: AWSURL
  postedAt: AWSDateTime!
  socialAccountId: ID! @index(name: "bySocialAccount", sortKeyFields: ["postedAt"])
}


# ===================================================================
# 10. CUSTOM OPERATIONS & NON-MODEL TYPES
# - Definitions for Lambda resolvers, inputs, and return types.
# ===================================================================

# --- Query & Mutation Definitions ---
type Query {
    fetchTournamentDataRange(startId: Int!, endId: Int!): [ScrapedGameSummary!] @function(name: "webScraperFunction-${env}")
}

type Mutation {
    fetchTournamentData(url: AWSURL!): ScrapedGameData @function(name: "webScraperFunction-${env}")
    saveTournamentData(input: SaveTournamentInput!): Game @function(name: "webScraperFunction-${env}")
}

# --- Operation Input Types ---
input SaveTournamentInput {
    sourceUrl: AWSURL!
    venueId: ID!
    existingGameId: ID
    doNotScrape: Boolean
    data: ScrapedGameDataInput!

    # This is the critical field to pass the full scraped object
    # through the API to the Lambda for SQS processing.
    originalScrapedData: AWSJSON
}

# This input remains clean for the database save operation.
# It does NOT contain entries, seating, or results.
input ScrapedGameDataInput {
    name: String!
    gameStartDateTime: String
    gameEndDateTime: String
    gameStatus: GameStatus
    registrationStatus: RegistrationStatus
    gameVariant: GameVariant
    gameType: GameType
    prizepool: Float
    totalEntries: Int
    totalRebuys: Int
    totalAddons: Int
    totalDuration: String
    gameTags: [String]
    tournamentType: TournamentType
    buyIn: Float
    rake: Float
    startingStack: Int
    hasGuarantee: Boolean
    guaranteeAmount: Float
    levels: [ScrapedTournamentLevelInput!]
}

input ScrapedTournamentLevelInput {
    levelNumber: Int!
    durationMinutes: Int
    smallBlind: Int
    bigBlind: Int
    ante: Int
    breakMinutes: Int
}

# --- Operation Return Types (Not @model) ---
type ScrapedGameSummary {
    id: String!
    name: String
    gameStatus: String
    registrationStatus: String
    gameStartDateTime: String
    inDatabase: Boolean
    doNotScrape: Boolean
    error: String
}

type ScrapedGameData {
    # Core Details
    name: String!
    gameStartDateTime: String
    gameEndDateTime: String
    gameStatus: GameStatus
    registrationStatus: String
    gameType: GameType
    gameVariant: GameVariant
    tournamentType: TournamentType
    
    # Financials
    prizepool: Float
    revenueByBuyIns: Float
    profitLoss: Float
    buyIn: Float
    rake: Float
    totalRake: Float
    startingStack: Int
    
    # Guarantee
    hasGuarantee: Boolean
    guaranteeAmount: Float
    guaranteeOverlay: Float
    guaranteeSurplus: Float
    
    # Aggregates
    totalEntries: Int
    totalRebuys: Int
    totalAddons: Int
    totalDuration: String

    # Live Data
    playersRemaining: Int
    totalChipsInPlay: Float
    averagePlayerStack: Float
    
    # Categorization
    seriesName: String
    isRegular: Boolean
    isSeries: Boolean
    isSatellite: Boolean
    gameFrequency: GameFrequency
    gameTags: [String]
    
    # Complex Structures
    levels: [ScrapedTournamentLevel!]
    breaks: [ScrapedBreak!]
    entries: [ScrapedPlayerEntry!]
    seating: [ScrapedPlayerSeating!]
    results: [ScrapedPlayerResult!]
    tables: [ScrapedTable!]

    # Scraper Metadata
    rawHtml: String
    isNewStructure: Boolean
    structureLabel: String
    foundKeys: [String]
    venueMatch: ScrapedVenueMatch
}

# --- Nested Scraped Data Types ---
type ScrapedTournamentLevel {
    levelNumber: Int!
    durationMinutes: Int
    smallBlind: Int
    bigBlind: Int
    ante: Int
}

type ScrapedBreak {
    levelNumberBeforeBreak: Int!
    durationMinutes: Int
}

type ScrapedPlayerEntry {
    name: String!
}

type ScrapedPlayerSeating {
    name: String!
    table: Int
    seat: Int
    playerStack: Int
}

type ScrapedPlayerResult {
    rank: Int!
    name: String!
    winnings: Float
    points: Float
}

type ScrapedTable {
    tableName: String!
    seats: [ScrapedTableSeatData!]
}

type ScrapedTableSeatData {
    seat: Int!
    isOccupied: Boolean!
    playerName: String
    playerStack: Int
}

type ScrapedVenueMatch {
    autoAssignedVenue: ScrapedVenueMatchDetails
    suggestions: [ScrapedVenueMatchDetails!]
}

type ScrapedVenueMatchDetails {
    id: ID!
    name: String!
    score: Float!
}