# 50-players.graphql
# ==========================================
# COMPLETE VERSION WITH PLAYERTICKET SOURCE TRACKING
# Version: 2.0.0
# ==========================================

type Player @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  primaryEntityId: ID @index(name: "byPrimaryEntity", queryField: "playersByEntity")
  firstName: String!
  lastName: String!
  phone: String @index(name: "byPhone", queryField: "playerByPhone")
  email: String @index(name: "byEmail", queryField: "playerByEmail")
  status: PlayerAccountStatus!
  category: PlayerAccountCategory!
  targetingClassification: PlayerTargetingClassification!
  registrationDate: AWSDateTime!
  firstGamePlayed: AWSDateTime
  lastPlayedDate: AWSDateTime
  creditBalance: Int
  pointsBalance: Int

  playerSummary: PlayerSummary @hasOne(fields: ["id"])
  knownIdentities: [KnownPlayerIdentity] @hasMany(indexName: "byPlayer", fields: ["id"])
  marketingPreferences: PlayerMarketingPreferences @hasOne(fields: ["id"])
  marketingMessages: [PlayerMarketingMessage] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerVenues: [PlayerVenue] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerEntries: [PlayerEntry] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerResults: [PlayerResult] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerTickets: [PlayerTicket] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerTransactions: [PlayerTransaction] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerCredits: [PlayerCredits] @hasMany(indexName: "byPlayer", fields: ["id"])
  playerPoints: [PlayerPoints] @hasMany(indexName: "byPlayer", fields: ["id"])

  venueAssignmentStatus: VenueAssignmentStatus @default(value: "PENDING_ASSIGNMENT")
  registrationVenueId: ID @index(name: "byRegistrationVenue")
  registrationVenue: Venue @belongsTo(fields: ["registrationVenueId"])
  updatedAt: AWSDateTime!
}

type PlayerSummary @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  playerId: ID! @index(name: "byPlayer")
  gamesPlayedLast30Days: Int
  gamesPlayedLast90Days: Int
  gamesPlayedAllTime: Int
  averageFinishPosition: Float
  netBalance: Float
  player: Player @belongsTo(fields: ["playerId"])
  sessionsPlayed: Int
  tournamentsPlayed: Int
  cashGamesPlayed: Int
  venuesVisited: Int
  tournamentWinnings: Float
  tournamentBuyIns: Float
  tournamentITM: Int
  tournamentsCashed: Int
  cashGameWinnings: Float
  cashGameBuyIns: Float
  totalWinnings: Float
  totalBuyIns: Float
  lastPlayed: AWSDateTime!
}

type PlayerEntry @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["gameStartDateTime"])
  gameId: ID! @index(name: "byGame")
  venueId: ID @index(name: "byVenue")
  entityId: ID @index(name: "byEntityEntry", sortKeyFields: ["gameStartDateTime"])
  
  status: PlayerEntryStatus!
  registrationTime: AWSDateTime!
  eliminationTime: AWSDateTime
  gameStartDateTime: AWSDateTime!
  lastKnownStackSize: Int
  tableNumber: Int
  seatNumber: Int
  numberOfReEntries: Int
  player: Player @belongsTo(fields: ["playerId"])
  game: Game @belongsTo(fields: ["gameId"])

  isMultiDayTournament: Boolean
  qualifyingGameId: ID
  entryType: EntryType @default(value: "INITIAL")
  recordType: String @default(value: "ORIGINAL") @index(name: "byRecordType", sortKeyFields: ["gameStartDateTime"])
}

type PlayerResult @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  finishingPlace: Int
  isMultiDayQualification: Boolean
  prizeWon: Boolean
  amountWon: Float
  totalRunners: Int
  pointsEarned: Float
  gameStartDateTime: AWSDateTime!
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["gameStartDateTime"])
  player: Player @belongsTo(fields: ["playerId"])
  gameId: ID! @index(name: "byGame")
  game: Game @belongsTo(fields: ["gameId"])
  recordType: String @default(value: "ORIGINAL") @index(name: "byRecordTypeResult", sortKeyFields: ["gameStartDateTime"])
  venueId: ID @index(name: "byVenueResult", sortKeyFields: ["gameStartDateTime"])
  entityId: ID @index(name: "byEntityResult", sortKeyFields: ["gameStartDateTime"])

  # Consolidation tracking
  isConsolidatedRecord: Boolean
  sourceEntryCount: Int
  sourceBuyInCount: Int
  totalBuyInsPaid: Float
  netProfitLoss: Float
  consolidatedIntoGameId: ID
}

type PlayerVenue @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["visityKey"])
  player: Player @belongsTo(fields: ["playerId"])
  
  venueId: ID! @index(name: "byVenue", sortKeyFields: ["playerId"])
  venue: Venue @belongsTo(fields: ["venueId"])
  
  entityId: ID! @index(name: "byEntityPlayerVenue", sortKeyFields: ["venueId"])
  visityKey: String @index(name: "byVisitKey", queryField: "playerVenueByVisitKey")
  canonicalVenueId: ID @index(name: "byCanonicalVenuePlayer", sortKeyFields: ["playerId"])
  
  totalGamesPlayed: Int
  averageBuyIn: Float
  totalBuyIns: Float
  totalWinnings: Float
  netProfit: Float
  firstPlayedDate: AWSDateTime
  lastPlayedDate: AWSDateTime
  
  targetingClassification: PlayerVenueTargetingClassification!
}

type PlayerTransaction @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  type: TransactionType!
  amount: Float!
  rake: Float
  paymentSource: PaymentSourceType!
  transactionDate: AWSDateTime!
  notes: String
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["transactionDate"])
  player: Player @belongsTo(fields: ["playerId"])
  gameId: ID @index(name: "byGame")
  venueId: ID @index(name: "byVenueTransaction", sortKeyFields: ["transactionDate"])
  entityId: ID @index(name: "byEntityTransaction", sortKeyFields: ["transactionDate"])
}

type PlayerCredits @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  type: CreditTransactionType!
  changeAmount: Float!
  balanceAfter: Float!
  transactionDate: AWSDateTime!
  reason: String
  expiryDate: AWSDateTime
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["transactionDate"])
  player: Player @belongsTo(fields: ["playerId"])
  relatedGameId: ID @index(name: "byGame")
  relatedTransactionId: ID
}

type PlayerPoints @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  type: PointsTransactionType!
  changeAmount: Float!
  balanceAfter: Float!
  transactionDate: AWSDateTime!
  reason: String
  expiryDate: AWSDateTime
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["transactionDate"])
  player: Player @belongsTo(fields: ["playerId"])
  relatedGameId: ID @index(name: "byGame")
  relatedTransactionId: ID
}

type KnownPlayerIdentity @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  sourceSystem: String!
  identityValue: String!
  identityType: String!
  playerId: ID! @index(name: "byPlayer")
  player: Player @belongsTo(fields: ["playerId"])
}

# ===================================================================
# TICKET TEMPLATE - Defines ticket programs (e.g., "Sydney Millions $250")
# ===================================================================

type TicketTemplate @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  description: String
  value: Float!
  validityDays: Int!
  
  # === SOURCE TRACKING ===
  # The recurring game that generates these tickets (for regular tournaments)
  # Note: No @belongsTo - use index to query templates by origin game
  originGameId: ID @index(name: "byOriginGame")
  
  # The target game these tickets can be used in (if specific)
  # Note: No @belongsTo - use index to query templates by target game
  targetGameId: ID @index(name: "byTargetGame")
  
  # Entity that owns this ticket program
  entityId: ID @index(name: "byEntityTemplate")
  
  # === RELATIONSHIPS ===
  playerTickets: [PlayerTicket] @hasMany(indexName: "byTicketTemplate", fields: ["id"])
  
  # === METADATA ===
  isActive: Boolean @default(value: "true")
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# ===================================================================
# PLAYER TICKET - Individual ticket awarded to a player
# UPDATED: Now tracks which game the ticket was won from
# ===================================================================

type PlayerTicket @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  
  # === CORE RELATIONSHIPS ===
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["assignedAt"])
  player: Player @belongsTo(fields: ["playerId"])
  
  ticketTemplateId: ID! @index(name: "byTicketTemplate")
  ticketTemplate: TicketTemplate @belongsTo(fields: ["ticketTemplateId"])
  
  # === NEW: SOURCE TRACKING ===
  # The game where this ticket was WON (enables Game.ticketsAwarded relationship)
  wonFromGameId: ID @index(name: "byWonFromGame", sortKeyFields: ["assignedAt"], queryField: "ticketsByWonFromGame")
  wonFromGame: Game @belongsTo(fields: ["wonFromGameId"])
  
  # Position that earned this ticket (e.g., 1-9 for "Top 9 get credits")
  wonFromPosition: Int
  
  # Entity and venue context (for reporting/filtering)
  entityId: ID @index(name: "byEntityTicket", sortKeyFields: ["assignedAt"])
  venueId: ID @index(name: "byVenueTicket", sortKeyFields: ["assignedAt"])
  
  # === TICKET STATUS ===
  status: TicketStatus!
  assignedAt: AWSDateTime!
  expiryDate: AWSDateTime
  
  # The game where this ticket was USED (redeemed)
  usedInGameId: ID @index(name: "byUsedInGame")
  usedAt: AWSDateTime
  
  # === DENORMALIZED TICKET INFO ===
  # Stored for quick access without joining to TicketTemplate
  ticketValue: Float
  programName: String
  awardReason: String

  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type MarketingMessage @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  subject: String
  emailBody: String
  smsBody: String
  sentMessages: [PlayerMarketingMessage] @hasMany(indexName: "byMarketingMessage", fields: ["id"])
}

type PlayerMarketingMessage @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  status: MessageStatus!
  sentAt: AWSDateTime!
  playerId: ID! @index(name: "byPlayer", sortKeyFields: ["sentAt"])
  marketingMessageId: ID! @index(name: "byMarketingMessage")
}

type PlayerMarketingPreferences @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  optOutSms: Boolean
  optOutEmail: Boolean
  playerId: ID! @index(name: "byPlayer")
  player: Player @belongsTo(fields: ["playerId"])
}

# ===================================================================
# INPUT TYPES
# ===================================================================

input SavePlayerDataInput {
  allPlayers: [SavePlayerInfoInput!]!
  totalInitialEntries: Int!
  totalEntries: Int!
  totalUniquePlayers: Int!
  hasCompleteResults: Boolean!
  totalPrizesPaid: Float
  hasEntryList: Boolean
  hasSeatingData: Boolean
}

input SavePlayerInfoInput {
  name: String!
  rank: Int
  winnings: Float
  points: Float
  isQualification: Boolean
  rebuys: Int
  addons: Int
}

input SaveProcessingOptionsInput {
  skipPlayerProcessing: Boolean
  forceUpdate: Boolean
  validateOnly: Boolean
  doNotScrape: Boolean
  priority: String
}

# ===================================================================
# TICKET MANAGEMENT INPUTS
# ===================================================================

input AwardTicketInput {
  playerId: ID!
  gameId: ID!
  position: Int!
  ticketValue: Float
  programName: String
  expiryDays: Int
}

input RedeemTicketInput {
  ticketId: ID!
  gameId: ID!
}

input BulkAwardTicketsInput {
  gameId: ID!
  awards: [TicketAwardInput!]!
  ticketValue: Float
  programName: String
}

input TicketAwardInput {
  playerId: ID!
  position: Int!
}

# ===================================================================
# TICKET MANAGEMENT OUTPUTS
# ===================================================================

type AwardTicketResult {
  success: Boolean!
  ticketId: ID
  playerId: ID
  ticketValue: Float
  error: String
}

type BulkAwardTicketsResult {
  success: Boolean!
  totalAwarded: Int!
  totalFailed: Int!
  results: [AwardTicketResult!]!
}

type TicketAwardSummary {
  gameId: ID!
  gameName: String
  ticketsAwarded: Int!
  ticketValue: Float
  totalTicketValue: Float
  programName: String
  positions: [Int]
}

type PlayerTicketConnection {
  items: [PlayerTicket!]!
  nextToken: String
}