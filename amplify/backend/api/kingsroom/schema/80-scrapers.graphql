# 80-scrapers.graphql
# ==========================================
# 
# FIXED VERSION: Uses composite key instead of dual @index on entityId
# This avoids the Amplify transformer bug that causes "Converting circular structure to JSON"
#
# CHANGE LOG:
# - Removed second @index from entityId (was causing deployment failure)
# - Added entityTournamentKey computed field for composite lookups
#
# DEPENDENCIES:
# - 00-enums.graphql: ScraperJobStatus, ScrapeAttemptStatus, ScrapeURLStatus, etc.
# - 30-games.graphql: SaveGameResult, SaveGameInput, SaveGameDataInput
# - Other files: SavePlayerDataInput, VenueReferenceInput, SaveProcessingOptionsInput, SaveVenueAssignmentInfo
#
# NOTE: This file should NOT redefine types that exist in other schema files.
# The following types are defined ELSEWHERE and must NOT be duplicated here:
# - SavePlayerDataInput
# - VenueReferenceInput  
# - SaveProcessingOptionsInput
# - SaveVenueAssignmentInfo
# ==========================================

# =============================================================================
# MODELS
# =============================================================================

type ScraperJob @model(queries: { list: null }) @auth(rules: [{ allow: private }]) {
  id: ID!
  jobId: String! @index(name: "byJobId")
  triggerSource: ScraperJobTriggerSource!
  triggeredBy: String
  startTime: AWSDateTime!
  endTime: AWSDateTime
  durationSeconds: Int
  maxGames: Int
  targetURLs: [String]
  isFullScan: Boolean
  startId: Int
  endId: Int
  status: ScraperJobStatus! @index(name: "byStatus", sortKeyFields: ["startTime"])
  totalURLsProcessed: Int
  newGamesScraped: Int
  gamesUpdated: Int
  gamesSkipped: Int
  errors: Int
  blanks: Int
  averageScrapingTime: Float
  successRate: Float
  errorMessages: [String]
  failedURLs: [String]
  urlResults: [ScraperJobURLResult]
  
  # Progress tracking (written by Lambda)
  currentId: Int
  stopReason: String
  lastErrorMessage: String
  notFoundCount: Int
  s3CacheHits: Int
  consecutiveNotFound: Int
  consecutiveErrors: Int
  consecutiveBlanks: Int

  scrapeAttempts: [ScrapeAttempt] @hasMany(indexName: "byScraperJob", fields: ["id"])
  entityId: ID @index(name: "byEntityScraperJob", sortKeyFields: ["startTime"])
  entity: Entity @belongsTo(fields: ["entityId"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type ScrapeURL @model(queries: { get: "getScrapeURL", list: null }) @auth(rules: [{ allow: private }]) {
  id: ID!
  url: AWSURL! @index(name: "byURL", queryField: "scrapeURLByURL")
  tournamentId: Int! @index(name: "byTournamentId")
  doNotScrape: Boolean!
  sourceDataIssue: Boolean
  gameDataVerified: Boolean
  missingKeysFromScrape: [String]
  sourceSystem: String @index(name: "bySourceSystem", queryField: "scrapeURLsBySourceSystem", sortKeyFields: ["tournamentId"])
  status: ScrapeURLStatus!
  placedIntoDatabase: Boolean!
  firstScrapedAt: AWSDateTime!
  lastScrapedAt: AWSDateTime!
  lastSuccessfulScrapeAt: AWSDateTime
  timesScraped: Int!
  timesSuccessful: Int!
  timesFailed: Int!
  consecutiveFailures: Int @default(value: "0")
  lastScrapeStatus: ScrapeAttemptStatus
  lastScrapeMessage: String
  lastScrapeJobId: String
  gameId: ID @index(name: "byGameId")
  gameName: String
  gameStatus: GameStatus
  venueId: ID
  venueName: String
  lastDataHash: String
  hasDataChanges: Boolean
  lastFoundKeys: [String]
  lastStructureLabel: String
  averageScrapingTime: Float
  lastScrapingTime: Float
  attempts: [ScrapeAttempt] @hasMany(indexName: "byScrapeURL", fields: ["id"])
  entityId: ID @index(name: "byEntityScrapeURL")
  entity: Entity @belongsTo(fields: ["entityId"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  etag: String
  lastModifiedHeader: String
  contentHash: String
  s3StoragePrefix: String
  latestS3Key: String
  s3StorageEnabled: Boolean @default(value: "true")
  lastContentChangeAt: AWSDateTime
  totalContentChanges: Int @default(value: "0")
  lastHeaderCheckAt: AWSDateTime
  cachedContentUsedCount: Int @default(value: "0")
  lastCacheHitAt: AWSDateTime
  contentSize: Int
  wasEdited: Boolean @default(value: "false")
}

type ScrapeAttempt @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  url: AWSURL!
  tournamentId: Int!
  attemptTime: AWSDateTime!
  scraperJobId: ID! @index(name: "byScraperJob", sortKeyFields: ["attemptTime"])
  scraperJob: ScraperJob @belongsTo(fields: ["scraperJobId"])
  scrapeURLId: ID! @index(name: "byScrapeURL", sortKeyFields: ["attemptTime"])
  scrapeURL: ScrapeURL @belongsTo(fields: ["scrapeURLId"])
  status: ScrapeAttemptStatus!
  processingTime: Float
  gameName: String
  gameStatus: GameStatus
  registrationStatus: RegistrationStatus
  dataHash: String
  hasChanges: Boolean
  errorMessage: String
  errorType: String
  gameId: ID @index(name: "byGame")
  wasNewGame: Boolean
  fieldsUpdated: [String]
  foundKeys: [String]
  structureLabel: String
  wasEdited: Boolean @default(value: "false")
  scrapedAt: AWSDateTime
  fieldsExtracted: [String]
  entityId: ID
  contentHash: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type ScraperState @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  isRunning: Boolean!
  lastScannedId: Int!
  lastRunStartTime: AWSDateTime
  lastRunEndTime: AWSDateTime
  consecutiveBlankCount: Int!
  totalScraped: Int!
  totalErrors: Int!
  enabled: Boolean!
  currentLog: [ScraperLogData]
  highestStoredId: Int
  lowestStoredId: Int
  knownGapRanges: AWSJSON
  lastGapScanAt: AWSDateTime
  totalGamesInDatabase: Int
  lastGamesProcessed: [ScrapedGameStatus]
  entityId: ID @index(name: "byEntityScraperState")
  entity: Entity @belongsTo(fields: ["entityId"])
}

type ScrapeStructure @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  fingerprint: String! @index(name: "byFingerprint", queryField: "scrapeStructuresByFingerprint")
  structureLabel: String!
  foundKeys: [String]!
  keyCount: Int
  hitCount: Int! @default(value: "1")
  firstSeenAt: AWSDateTime!
  lastSeenAt: AWSDateTime!
  exampleUrl: AWSURL
  isActive: Boolean @default(value: "true")
}

type DataSync @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  syncedAt: AWSDateTime!
  method: DataSource!
  sourceUrl: AWSURL
  title: String
  content: String
}

# ═══════════════════════════════════════════════════════════════════════════════
# S3Storage - FIXED VERSION
# ═══════════════════════════════════════════════════════════════════════════════
# 
# SOLUTION: Use composite key field instead of dual @index
# 
# entityTournamentKey: Computed field storing "{entityId}#{tournamentId}"
# - Set by Lambda on create/update
# - Enables direct lookup without needing scrapedAt
# - Works with migrated records missing scrapedAt
# - Avoids Amplify transformer bug with dual @index
#
# QUERY USAGE:
#   KeyConditionExpression: 'entityTournamentKey = :key'
#   ExpressionAttributeValues: { ':key': `${entityId}#${tournamentId}` }
# ═══════════════════════════════════════════════════════════════════════════════

type S3Storage @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  scrapeURLId: ID @index(name: "byScrapeURL", sortKeyFields: ["scrapedAt"])
  url: AWSURL! @index(name: "byURL", sortKeyFields: ["scrapedAt"])
  tournamentId: Int! @index(name: "byTournamentId", sortKeyFields: ["scrapedAt"])
  
  # Primary entity index (for listing all S3Storage by entity)
  entityId: ID! @index(name: "byEntity", sortKeyFields: ["scrapedAt"])
  
  # NEW: Composite key for direct entity+tournament lookups
  # Format: "{entityId}#{tournamentId}"
  # Set by Lambda: entityTournamentKey = `${entityId}#${tournamentId}`
  entityTournamentKey: String @index(name: "byEntityTournament")
  
  s3Key: String! @index(name: "byS3Key")
  s3Bucket: String!
  scrapedAt: AWSDateTime!
  contentSize: Int
  contentHash: String
  etag: String
  lastModified: String
  headers: AWSJSON
  dataExtracted: Boolean @default(value: "false")
  gameId: ID @index(name: "byGameId")
  isManualUpload: Boolean @default(value: "false")
  uploadedBy: String
  notes: String
  previousVersions: [S3VersionHistory]
  gameStatus: String @index(name: "byS3GameStatus", queryField: "s3StorageByGameStatus", sortKeyFields: ["scrapedAt"])
  registrationStatus: String @index(name: "byS3RegistrationStatus", queryField: "s3StorageByRegistrationStatus", sortKeyFields: ["scrapedAt"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  isParsed: Boolean @default(value: "false")
  parsedDataHash: String
  extractedFields: [String]
  lastParsedAt: AWSDateTime
  parseCount: Int @default(value: "0")
  rescrapeCount: Int @default(value: "0")
  lastRescrapeAt: AWSDateTime
  dataChangedAt: AWSDateTime
  dataChangeCount: Int @default(value: "0")
}

# =============================================================================
# NON-MODEL RESPONSE TYPES
# =============================================================================

type ScraperControlResponse {
  success: Boolean!
  message: String
  state: ScraperStateData
  results: ScraperResults
}

type ScraperStateData {
  id: String!
  isRunning: Boolean!
  lastScannedId: Int!
  lastRunStartTime: String
  lastRunEndTime: String
  consecutiveBlankCount: Int!
  totalScraped: Int!
  totalErrors: Int!
  enabled: Boolean!
  currentLog: [ScraperLogData]
  lastGamesProcessed: [ScrapedGameStatus]
  entityId: String
}

type ScraperResults {
  newGamesScraped: Int!
  gamesUpdated: Int!
  errors: Int!
  blanks: Int!
}

type ScraperLogData {
  timestamp: AWSDateTime!
  level: String!
  message: String!
  details: String
}

type ScrapedGameStatus {
  id: Int!
  name: String!
  status: String!
}

type ScraperJobURLResult {
  url: String!
  tournamentId: Int!
  status: ScrapeAttemptStatus!
  gameName: String
  processingTime: Float
  error: String
}

type ScraperMetrics {
  totalJobs: Int!
  successfulJobs: Int!
  failedJobs: Int!
  averageJobDuration: Float!
  totalURLsScraped: Int!
  successRate: Float!
  topErrors: [ErrorMetric!]
  hourlyActivity: [HourlyMetric!]
  byEntity: [EntityScraperMetrics]
}

type ScrapedGameSummary {
  id: String!
  name: String
  gameStatus: String
  registrationStatus: String
  gameStartDateTime: String
  inDatabase: Boolean
  doNotScrape: Boolean
  error: String
}

# =============================================================================
# SCRAPED DATA TYPES (with IAM auth for Lambda access)
# =============================================================================

type ScrapedGameData @aws_iam @aws_cognito_user_pools {
  name: String!
  gameStartDateTime: String
  gameEndDateTime: String
  gameStatus: GameStatus
  registrationStatus: String
  gameType: GameType
  gameVariant: GameVariant
  tournamentType: TournamentType
  prizepoolPaid: Float
  prizepoolCalculated: Float
  buyIn: Float
  rake: Float
  startingStack: Int
  hasGuarantee: Boolean
  guaranteeAmount: Float
  totalUniquePlayers: Int
  totalInitialEntries: Int
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  totalDuration: String
  playersRemaining: Int
  totalChipsInPlay: Float
  averagePlayerStack: Float
  seriesName: String
  isRegular: Boolean
  isSeries: Boolean
  isSatellite: Boolean
  tournamentSeriesId: ID
  seriesTitleId: ID
  isMainEvent: Boolean
  eventNumber: Int
  dayNumber: Int
  flightLetter: String
  finalDay: Boolean
  seriesYear: Int
  gameFrequency: GameFrequency
  gameTags: [String]
  levels: [ScrapedTournamentLevel!]
  breaks: [ScrapedBreak!]
  entries: [ScrapedPlayerEntry!]
  seating: [ScrapedPlayerSeating!]
  results: [ScrapedPlayerResult!]
  tables: [ScrapedTable!]
  rawHtml: String
  isNewStructure: Boolean
  structureLabel: String
  foundKeys: [String]
  venueMatch: ScrapedVenueMatch
  existingGameId: String
  doNotScrape: Boolean
  skipped: Boolean
  skipReason: String
  tournamentId: Int!
  entityId: ID
  sourceUrl: AWSURL
  s3Key: String
  source: String
  contentHash: String
  fetchedAt: AWSDateTime
  reScrapedAt: AWSDateTime
  wasForced: Boolean
  totalBuyInsCollected: Float
  rakeRevenue: Float
  prizepoolPlayerContributions: Float
  prizepoolAddedValue: Float
  prizepoolSurplus: Float
  guaranteeOverlayCost: Float
  gameProfit: Float
  venueAssignmentStatus: VenueAssignmentStatus
  error: String
  errorMessage: String
  status: String
  httpStatus: Int
}

type ScrapedTournamentLevel @aws_iam @aws_cognito_user_pools {
  levelNumber: Int!
  durationMinutes: Int
  smallBlind: Int
  bigBlind: Int
  ante: Int
}

type ScrapedBreak @aws_iam @aws_cognito_user_pools {
  levelNumberBeforeBreak: Int!
  durationMinutes: Int
}

type ScrapedPlayerEntry @aws_iam @aws_cognito_user_pools {
  name: String!
}

type ScrapedPlayerSeating @aws_iam @aws_cognito_user_pools {
  name: String!
  table: Int
  seat: Int
  playerStack: Int
}

type ScrapedPlayerResult @aws_iam @aws_cognito_user_pools {
  rank: Int!
  name: String!
  winnings: Float
  points: Float
  isQualification: Boolean
}

type ScrapedTable @aws_iam @aws_cognito_user_pools {
  tableName: String!
  seats: [ScrapedTableSeatData!]
}

type ScrapedTableSeatData @aws_iam @aws_cognito_user_pools {
  seat: Int!
  isOccupied: Boolean!
  playerName: String
  playerStack: Int
}

type ScrapedVenueMatch @aws_iam @aws_cognito_user_pools {
  autoAssignedVenue: ScrapedVenueMatchDetails
  suggestions: [ScrapedVenueMatchDetails!]
}

type ScrapedVenueMatchDetails @aws_iam @aws_cognito_user_pools {
  id: ID!
  name: String!
  score: Float!
}

# =============================================================================
# REPORT & LIST TYPES
# =============================================================================

type ScraperJobsReport {
  items: [ScraperJob]
  nextToken: String
  totalCount: Int
  entitySummary: [EntityJobSummary]
}

type GapRange {
  start: Int!
  end: Int!
  count: Int!
}

type GapSummary {
  totalGaps: Int!
  totalMissingIds: Int!
  largestGapStart: Int
  largestGapEnd: Int
  largestGapCount: Int
  coveragePercentage: Float!
}

type S3VersionHistory {
  s3Key: String!
  scrapedAt: AWSDateTime!
  contentHash: String
  uploadedBy: String
  contentSize: Int
}

type CachingStatsResponse {
  totalURLs: Int!
  urlsWithETags: Int!
  urlsWithLastModified: Int!
  totalCacheHits: Int!
  totalCacheMisses: Int!
  averageCacheHitRate: Float!
  storageUsedMB: Float!
  recentCacheActivity: [CacheActivityLog!]
}

type S3ContentResponse {
  s3Key: String!
  html: String!
  metadata: AWSJSON
  size: Int
  lastModified: AWSDateTime
}

type S3StorageHistoryResponse {
  items: [S3Storage]
  nextToken: String
}

type S3StorageListResponse {
  items: [S3Storage]
  nextToken: String
}

type S3StorageConnection {
  items: [S3Storage!]!
  nextToken: String
}

type ScraperJobConnection {
  items: [ScraperJob!]
  nextToken: String
}

type ScrapeURLConnection {
  items: [ScrapeURL]
  nextToken: String
  totalCount: Int
}

# =============================================================================
# LEGACY INPUT TYPES (for frontend direct saves)
# =============================================================================

input SaveTournamentInput {
  sourceUrl: AWSURL!
  venueId: ID
  existingGameId: ID
  doNotScrape: Boolean
  data: ScrapedGameDataInput!
  originalScrapedData: AWSJSON
  venueAssignmentStatus: VenueAssignmentStatus
  requiresVenueAssignment: Boolean
  suggestedVenueName: String
  venueAssignmentConfidence: Float
  entityId: ID
}

input ScrapedGameDataInput {
  name: String!
  gameStartDateTime: String
  gameEndDateTime: String
  gameStatus: GameStatus
  registrationStatus: RegistrationStatus
  gameVariant: GameVariant
  gameType: GameType
  prizepoolPaid: Float
  prizepoolCalculated: Float
  totalUniquePlayers: Int
  totalInitialEntries: Int
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  totalDuration: String
  gameTags: [String]
  tournamentType: TournamentType
  buyIn: Float
  rake: Float
  startingStack: Int
  hasGuarantee: Boolean
  guaranteeAmount: Float
  levels: [ScrapedTournamentLevelInput!]
}

input ScrapedTournamentLevelInput {
  levelNumber: Int!
  durationMinutes: Int
  smallBlind: Int
  bigBlind: Int
  ante: Int
  breakMinutes: Int
}