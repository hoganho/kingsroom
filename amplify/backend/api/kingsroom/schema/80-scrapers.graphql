# 80-scrapers.graphql
# ==========================================

type ScraperJob @model(queries: { list: null }) @auth(rules: [{ allow: private }]) {
  id: ID!
  jobId: String! @index(name: "byJobId")
  triggerSource: ScraperJobTriggerSource!
  triggeredBy: String
  startTime: AWSDateTime!
  endTime: AWSDateTime
  durationSeconds: Int
  maxGames: Int
  targetURLs: [String]
  isFullScan: Boolean
  startId: Int
  endId: Int
  status: ScraperJobStatus! @index(name: "byStatus", sortKeyFields: ["startTime"])
  totalURLsProcessed: Int
  newGamesScraped: Int
  gamesUpdated: Int
  gamesSkipped: Int
  errors: Int
  blanks: Int
  averageScrapingTime: Float
  successRate: Float
  errorMessages: [String]
  failedURLs: [String]
  urlResults: [ScraperJobURLResult]
  scrapeAttempts: [ScrapeAttempt] @hasMany(indexName: "byScraperJob", fields: ["id"])
  entityId: ID @index(name: "byEntityScraperJob", sortKeyFields: ["startTime"])
  entity: Entity @belongsTo(fields: ["entityId"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type ScrapeURL @model(queries: { get: "getScrapeURL", list: null }) @auth(rules: [{ allow: private }]) {
  id: ID!
  url: AWSURL! @index(name: "byURL", queryField: "scrapeURLByURL")
  tournamentId: Int! @index(name: "byTournamentId")
  doNotScrape: Boolean!
  sourceDataIssue: Boolean
  gameDataVerified: Boolean
  missingKeysFromScrape: [String]
  sourceSystem: String @index(name: "bySourceSystem", queryField: "scrapeURLsBySourceSystem", sortKeyFields: ["tournamentId"])
  status: ScrapeURLStatus!
  placedIntoDatabase: Boolean!
  firstScrapedAt: AWSDateTime!
  lastScrapedAt: AWSDateTime!
  lastSuccessfulScrapeAt: AWSDateTime
  timesScraped: Int!
  timesSuccessful: Int!
  timesFailed: Int!
  consecutiveFailures: Int @default(value: "0")
  lastScrapeStatus: ScrapeAttemptStatus
  lastScrapeMessage: String
  lastScrapeJobId: String
  gameId: ID @index(name: "byGameId")
  gameName: String
  gameStatus: GameStatus
  venueId: ID
  venueName: String
  lastDataHash: String
  hasDataChanges: Boolean
  lastFoundKeys: [String]
  lastStructureLabel: String
  averageScrapingTime: Float
  lastScrapingTime: Float
  attempts: [ScrapeAttempt] @hasMany(indexName: "byScrapeURL", fields: ["id"])
  entityId: ID @index(name: "byEntityScrapeURL")
  entity: Entity @belongsTo(fields: ["entityId"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!

  etag: String
  lastModifiedHeader: String
  contentHash: String
  s3StoragePrefix: String
  latestS3Key: String
  s3StorageEnabled: Boolean @default(value: "true")
  lastContentChangeAt: AWSDateTime
  totalContentChanges: Int @default(value: "0")
  lastHeaderCheckAt: AWSDateTime
  cachedContentUsedCount: Int @default(value: "0")
  lastCacheHitAt: AWSDateTime
  contentSize: Int
  wasEdited: Boolean @default(value: "false")
}

type ScrapeAttempt @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  url: AWSURL!
  tournamentId: Int!
  attemptTime: AWSDateTime!
  scraperJobId: ID! @index(name: "byScraperJob", sortKeyFields: ["attemptTime"])
  scraperJob: ScraperJob @belongsTo(fields: ["scraperJobId"])
  scrapeURLId: ID! @index(name: "byScrapeURL", sortKeyFields: ["attemptTime"])
  scrapeURL: ScrapeURL @belongsTo(fields: ["scrapeURLId"])
  status: ScrapeAttemptStatus!
  processingTime: Float
  gameName: String
  gameStatus: GameStatus
  registrationStatus: RegistrationStatus
  dataHash: String
  hasChanges: Boolean
  errorMessage: String
  errorType: String
  gameId: ID
  wasNewGame: Boolean
  fieldsUpdated: [String]
  foundKeys: [String]
  structureLabel: String
  wasEdited: Boolean @default(value: "false")
  scrapedAt: AWSDateTime
  fieldsExtracted: [String]
  entityId: ID
  contentHash: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type ScraperState @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  isRunning: Boolean!
  lastScannedId: Int!
  lastRunStartTime: AWSDateTime
  lastRunEndTime: AWSDateTime
  consecutiveBlankCount: Int!
  totalScraped: Int!
  totalErrors: Int!
  enabled: Boolean!
  currentLog: [ScraperLogData]
  highestStoredId: Int
  lowestStoredId: Int
  knownGapRanges: AWSJSON
  lastGapScanAt: AWSDateTime
  totalGamesInDatabase: Int
  lastGamesProcessed: [ScrapedGameStatus]
  entityId: ID @index(name: "byEntityScraperState")
  entity: Entity @belongsTo(fields: ["entityId"])
}

type ScrapeStructure @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  fields: [String]!
  structureLabel: String!
  occurrenceCount: Int!
  firstSeenAt: AWSDateTime!
  lastSeenAt: AWSDateTime!
  exampleUrl: AWSURL
}

type DataSync @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  syncedAt: AWSDateTime!
  method: DataSource!
  sourceUrl: AWSURL
  title: String
  content: String
}

type S3Storage @model(subscriptions: null) @auth(rules: [{ allow: private }]) {
  id: ID!
  scrapeURLId: ID @index(name: "byScrapeURL", sortKeyFields: ["scrapedAt"])
  url: AWSURL! @index(name: "byURL", sortKeyFields: ["scrapedAt"])
  tournamentId: Int! @index(name: "byTournamentId", sortKeyFields: ["scrapedAt"])
  entityId: ID! @index(name: "byEntity", sortKeyFields: ["scrapedAt"])
  s3Key: String! @index(name: "byS3Key")
  s3Bucket: String!
  scrapedAt: AWSDateTime!
  contentSize: Int
  contentHash: String
  etag: String
  lastModified: String
  headers: AWSJSON
  dataExtracted: Boolean @default(value: "false")
  gameId: ID @index(name: "byGameId")
  isManualUpload: Boolean @default(value: "false")
  uploadedBy: String
  notes: String
  previousVersions: [S3VersionHistory]
  gameStatus: String @index(name: "byS3GameStatus", queryField: "s3StorageByGameStatus", sortKeyFields: ["scrapedAt"])
  registrationStatus: String @index(name: "byS3RegistrationStatus", queryField: "s3StorageByRegistrationStatus", sortKeyFields: ["scrapedAt"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!

  isParsed: Boolean @default(value: "false")
  parsedDataHash: String
  extractedFields: [String]
  lastParsedAt: AWSDateTime
  parseCount: Int @default(value: "0")
  rescrapeCount: Int @default(value: "0")
  lastRescrapeAt: AWSDateTime
  dataChangedAt: AWSDateTime
  dataChangeCount: Int @default(value: "0")
}

type ScraperControlResponse {
  success: Boolean!
  message: String
  state: ScraperStateData
  results: ScraperResults
}

type ScraperStateData {
  id: String!
  isRunning: Boolean!
  lastScannedId: Int!
  lastRunStartTime: String
  lastRunEndTime: String
  consecutiveBlankCount: Int!
  totalScraped: Int!
  totalErrors: Int!
  enabled: Boolean!
  currentLog: [ScraperLogData]
  lastGamesProcessed: [ScrapedGameStatus]
  entityId: String
}

type ScraperResults {
  newGamesScraped: Int!
  gamesUpdated: Int!
  errors: Int!
  blanks: Int!
}

type ScraperLogData {
  timestamp: AWSDateTime!
  level: String!
  message: String!
  details: String
}

type ScrapedGameStatus {
  id: Int!
  name: String!
  status: String!
}

type ScraperJobURLResult {
  url: String!
  tournamentId: Int!
  status: ScrapeAttemptStatus!
  gameName: String
  processingTime: Float
  error: String
}

type ScraperMetrics {
  totalJobs: Int!
  successfulJobs: Int!
  failedJobs: Int!
  averageJobDuration: Float!
  totalURLsScraped: Int!
  successRate: Float!
  topErrors: [ErrorMetric!]
  hourlyActivity: [HourlyMetric!]
  byEntity: [EntityScraperMetrics]
}

type ScrapedGameSummary {
  id: String!
  name: String
  gameStatus: String
  registrationStatus: String
  gameStartDateTime: String
  inDatabase: Boolean
  doNotScrape: Boolean
  error: String
}

type ScrapedGameData {
  name: String!
  gameStartDateTime: String
  gameEndDateTime: String
  gameStatus: GameStatus
  registrationStatus: String
  gameType: GameType
  gameVariant: GameVariant
  tournamentType: TournamentType
  prizepoolPaid: Float
  prizepoolCalculated: Float
  buyIn: Float
  rake: Float
  startingStack: Int
  hasGuarantee: Boolean
  guaranteeAmount: Float
  totalUniquePlayers: Int
  totalInitialEntries: Int
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  totalDuration: String
  playersRemaining: Int
  totalChipsInPlay: Float
  averagePlayerStack: Float
  seriesName: String
  isRegular: Boolean
  isSeries: Boolean
  isSatellite: Boolean
  tournamentSeriesId: ID
  seriesTitleId: ID
  isMainEvent: Boolean
  eventNumber: Int
  dayNumber: Int
  flightLetter: String
  finalDay: Boolean
  seriesYear: Int
  gameFrequency: GameFrequency
  gameTags: [String]
  levels: [ScrapedTournamentLevel!]
  breaks: [ScrapedBreak!]
  entries: [ScrapedPlayerEntry!]
  seating: [ScrapedPlayerSeating!]
  results: [ScrapedPlayerResult!]
  tables: [ScrapedTable!]
  rawHtml: String
  isNewStructure: Boolean
  structureLabel: String
  foundKeys: [String]
  venueMatch: ScrapedVenueMatch
  existingGameId: String
  doNotScrape: Boolean
  skipped: Boolean
  skipReason: String
  tournamentId: Int!
  entityId: ID
  sourceUrl: AWSURL
  s3Key: String
  source: String
  contentHash: String
  fetchedAt: AWSDateTime
  reScrapedAt: AWSDateTime
  wasForced: Boolean
  totalBuyInsCollected: Float
  rakeRevenue: Float
  prizepoolPlayerContributions: Float
  prizepoolAddedValue: Float
  prizepoolSurplus: Float
  guaranteeOverlayCost: Float
  gameProfit: Float
  venueAssignmentStatus: VenueAssignmentStatus

  # Primary error message from Lambda
  error: String
  # Alternative error message field (some responses use this)
  errorMessage: String
  # Status indicator: 'SUCCESS', 'ERROR', 'SKIPPED', etc.
  status: String
  # HTTP status code from scraper (200, 401, 403, 404, 429, 500, etc.)
  httpStatus: Int
}

type ScrapedTournamentLevel {
  levelNumber: Int!
  durationMinutes: Int
  smallBlind: Int
  bigBlind: Int
  ante: Int
}

type ScrapedBreak {
  levelNumberBeforeBreak: Int!
  durationMinutes: Int
}

type ScrapedPlayerEntry {
  name: String!
}

type ScrapedPlayerSeating {
  name: String!
  table: Int
  seat: Int
  playerStack: Int
}

type ScrapedPlayerResult {
  rank: Int!
  name: String!
  winnings: Float
  points: Float
  isQualification: Boolean
}

type ScrapedTable {
  tableName: String!
  seats: [ScrapedTableSeatData!]
}

type ScrapedTableSeatData {
  seat: Int!
  isOccupied: Boolean!
  playerName: String
  playerStack: Int
}

type ScrapedVenueMatch {
  autoAssignedVenue: ScrapedVenueMatchDetails
  suggestions: [ScrapedVenueMatchDetails!]
}

type ScrapedVenueMatchDetails {
  id: ID!
  name: String!
  score: Float!
}

type ScraperJobsReport {
  items: [ScraperJob]
  nextToken: String
  totalCount: Int           # Optional
  entitySummary: [EntityJobSummary]  # NEW: Optional per-entity breakdown
}

type GapRange {
  start: Int!
  end: Int!
  count: Int!
}

type GapSummary {
  totalGaps: Int!
  totalMissingIds: Int!
  largestGapStart: Int
  largestGapEnd: Int
  largestGapCount: Int
  coveragePercentage: Float!
}

type S3VersionHistory {
  s3Key: String!
  scrapedAt: AWSDateTime!
  contentHash: String
  uploadedBy: String
  contentSize: Int
}

type CachingStatsResponse {
  totalURLs: Int!
  urlsWithETags: Int!
  urlsWithLastModified: Int!
  totalCacheHits: Int!
  totalCacheMisses: Int!
  averageCacheHitRate: Float!
  storageUsedMB: Float!
  recentCacheActivity: [CacheActivityLog!]
}

type S3ContentResponse {
  s3Key: String!
  html: String!
  metadata: AWSJSON
  size: Int
  lastModified: AWSDateTime
}

type S3StorageHistoryResponse {
  items: [S3Storage]
  nextToken: String
}

type S3StorageListResponse {
  items: [S3Storage]
  nextToken: String
}

type S3StorageConnection {
  items: [S3Storage!]!
  nextToken: String
}

type ScraperJobConnection {
  items: [ScraperJob!]
  nextToken: String
}

type ScrapeURLConnection {
  items: [ScrapeURL]
  nextToken: String
  totalCount: Int           # Optional: for showing total matching records
}

input SaveTournamentInput {
  sourceUrl: AWSURL!
  venueId: ID
  existingGameId: ID
  doNotScrape: Boolean
  data: ScrapedGameDataInput!
  originalScrapedData: AWSJSON
  venueAssignmentStatus: VenueAssignmentStatus
  requiresVenueAssignment: Boolean
  suggestedVenueName: String
  venueAssignmentConfidence: Float
  entityId: ID
}

input ScrapedGameDataInput {
  name: String!
  gameStartDateTime: String
  gameEndDateTime: String
  gameStatus: GameStatus
  registrationStatus: RegistrationStatus
  gameVariant: GameVariant
  gameType: GameType
  prizepoolPaid: Float
  prizepoolCalculated: Float
  totalUniquePlayers: Int
  totalInitialEntries: Int
  totalEntries: Int
  totalRebuys: Int
  totalAddons: Int
  totalDuration: String
  gameTags: [String]
  tournamentType: TournamentType
  buyIn: Float
  rake: Float
  startingStack: Int
  hasGuarantee: Boolean
  guaranteeAmount: Float
  levels: [ScrapedTournamentLevelInput!]
}

input ScrapedTournamentLevelInput {
  levelNumber: Int!
  durationMinutes: Int
  smallBlind: Int
  bigBlind: Int
  ante: Int
  breakMinutes: Int
}